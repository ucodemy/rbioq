{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contexto docente \u00b6 Este tutorial se enmarca dentro del \u00e1mbito de la materia \"Inform\u00e1tica Aplicada a la Bioqu\u00edmica\". Dicha materia se imparte en la asignatura con el mismo nombre durante el segundo curso del Grado en Bioqu\u00edmica en la Universidad de C\u00f3rdoba. El objetivo de este tutorial es introducir los elementos m\u00e1s importantes del lenguaje de programaci\u00f3n R, de un modo guiado y eminentemente pr\u00e1ctico, a un nuevo estudiante de Grado en Bioqu\u00edmica y todo aquel que se inicie en el \u00e1rea de la programaci\u00f3n, ya que este lenguaje es tan amplio, y existen tantas bibliotecas de funciones que lo extienden, que es necesario acotar su ense\u00f1anza a solo aquellas funcionalidades que se prev\u00e9 que sean de utilidad para la gran mayor\u00eda de estudiantes de Bioqu\u00edmica, no solo para aquellos que finalmente se declinen para una orientaci\u00f3n Bioinform\u00e1tica. El aprendizaje de programaci\u00f3n y, especialmente, R, abren al bioqu\u00edmico muchas puertas en su futuro profesional, ya que los laboratorios de bioinform\u00e1tica cada vez son m\u00e1s y realizan funciones de gran importancia como el alineamiento de secuencias, la predicci\u00f3n de genes, montaje del genoma, alineamiento estructural de prote\u00ednas, predicci\u00f3n de estructura de prote\u00ednas, predicci\u00f3n de la expresi\u00f3n g\u00e9nica, interacciones prote\u00edna-prote\u00edna, y modelado de la evoluci\u00f3n. As\u00ed, la presencia de bioinform\u00e1ticos en grupos de investigaci\u00f3n donde los principales estudios requieren de la manipulaci\u00f3n f\u00edsica en laboratorios es esencial, y aquellos que disponen de conocimientos sobre programaci\u00f3n logran hacerse indispensables en dichos lugares. Introducci\u00f3n a R \u00b6 R es un lenguaje de programaci\u00f3n que naci\u00f3 en 1993 en el Departamento de Estad\u00edstica de Auckland, donde Robert Gentleman y Ross Ihaka combinaron dos lenguajes ya existentes, S y Scheme. Como an\u00e9cdota, unos comentan que la denominaci\u00f3n R es un reconocimiento a estos lenguajes, otros indican que sus creadores comenzaron a llamarlo R debido a la inicial de sus nombres. Actualmente su desarrollo es responsabilidad de R Development core Team y se encuentra disponible aqu\u00ed en la versi\u00f3n 3.6.3 para los sistemas operativos Windows, Macintosh, Unix y GNU/Linux. El crecimiento de este lenguaje se est\u00e1 extendiendo a los campos de aprendizaje autom\u00e1tico (machine learning), miner\u00eda de datos, investigaci\u00f3n biom\u00e9dica, bioinform\u00e1tica y matem\u00e1ticas financieras, y se debe al amplio gran de herramientas y facilidades que proporciona. R destaca por su enfoque estad\u00edstico y la alta calidad de generaci\u00f3n de gr\u00e1ficos, pero tambi\u00e9n por otras caracter\u00edsticas resaltables como la amplia presencia de bibliotecas que permiten la interpretaci\u00f3n de otros lenguajes de forma m\u00e1s din\u00e1mica. Cabe mencionar que R forma parte del proyecto colaborativo y abierto GNU, por lo que sus usuarios pueden publicar paquetes de funciones que extienden su configuraci\u00f3n b\u00e1sica. De hecho, existe un repositorio oficial de paquetes, The Comprehensive R Archive Network (CRAN) , que los agrupa seg\u00fan su funci\u00f3n y naturaleza. Enlaces de inter\u00e9s A Brief History R. Ross Ihaka, University of Auckland . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n.","title":"Inicio"},{"location":"#contexto-docente","text":"Este tutorial se enmarca dentro del \u00e1mbito de la materia \"Inform\u00e1tica Aplicada a la Bioqu\u00edmica\". Dicha materia se imparte en la asignatura con el mismo nombre durante el segundo curso del Grado en Bioqu\u00edmica en la Universidad de C\u00f3rdoba. El objetivo de este tutorial es introducir los elementos m\u00e1s importantes del lenguaje de programaci\u00f3n R, de un modo guiado y eminentemente pr\u00e1ctico, a un nuevo estudiante de Grado en Bioqu\u00edmica y todo aquel que se inicie en el \u00e1rea de la programaci\u00f3n, ya que este lenguaje es tan amplio, y existen tantas bibliotecas de funciones que lo extienden, que es necesario acotar su ense\u00f1anza a solo aquellas funcionalidades que se prev\u00e9 que sean de utilidad para la gran mayor\u00eda de estudiantes de Bioqu\u00edmica, no solo para aquellos que finalmente se declinen para una orientaci\u00f3n Bioinform\u00e1tica. El aprendizaje de programaci\u00f3n y, especialmente, R, abren al bioqu\u00edmico muchas puertas en su futuro profesional, ya que los laboratorios de bioinform\u00e1tica cada vez son m\u00e1s y realizan funciones de gran importancia como el alineamiento de secuencias, la predicci\u00f3n de genes, montaje del genoma, alineamiento estructural de prote\u00ednas, predicci\u00f3n de estructura de prote\u00ednas, predicci\u00f3n de la expresi\u00f3n g\u00e9nica, interacciones prote\u00edna-prote\u00edna, y modelado de la evoluci\u00f3n. As\u00ed, la presencia de bioinform\u00e1ticos en grupos de investigaci\u00f3n donde los principales estudios requieren de la manipulaci\u00f3n f\u00edsica en laboratorios es esencial, y aquellos que disponen de conocimientos sobre programaci\u00f3n logran hacerse indispensables en dichos lugares.","title":"Contexto docente"},{"location":"#introduccion-a-r","text":"R es un lenguaje de programaci\u00f3n que naci\u00f3 en 1993 en el Departamento de Estad\u00edstica de Auckland, donde Robert Gentleman y Ross Ihaka combinaron dos lenguajes ya existentes, S y Scheme. Como an\u00e9cdota, unos comentan que la denominaci\u00f3n R es un reconocimiento a estos lenguajes, otros indican que sus creadores comenzaron a llamarlo R debido a la inicial de sus nombres. Actualmente su desarrollo es responsabilidad de R Development core Team y se encuentra disponible aqu\u00ed en la versi\u00f3n 3.6.3 para los sistemas operativos Windows, Macintosh, Unix y GNU/Linux. El crecimiento de este lenguaje se est\u00e1 extendiendo a los campos de aprendizaje autom\u00e1tico (machine learning), miner\u00eda de datos, investigaci\u00f3n biom\u00e9dica, bioinform\u00e1tica y matem\u00e1ticas financieras, y se debe al amplio gran de herramientas y facilidades que proporciona. R destaca por su enfoque estad\u00edstico y la alta calidad de generaci\u00f3n de gr\u00e1ficos, pero tambi\u00e9n por otras caracter\u00edsticas resaltables como la amplia presencia de bibliotecas que permiten la interpretaci\u00f3n de otros lenguajes de forma m\u00e1s din\u00e1mica. Cabe mencionar que R forma parte del proyecto colaborativo y abierto GNU, por lo que sus usuarios pueden publicar paquetes de funciones que extienden su configuraci\u00f3n b\u00e1sica. De hecho, existe un repositorio oficial de paquetes, The Comprehensive R Archive Network (CRAN) , que los agrupa seg\u00fan su funci\u00f3n y naturaleza. Enlaces de inter\u00e9s A Brief History R. Ross Ihaka, University of Auckland . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n.","title":"Introducci\u00f3n a R"},{"location":"RStudio/","text":"RStudio es una entorno de desarrollo integrado (IDE) que se emplea de forma m\u00e1s usual, puesto que es gratuito, de c\u00f3digo abierto, con un editor incorporado, funciona en todas las plataformas y ofrece muchas ventajas, como la integraci\u00f3n de control de versiones y gesti\u00f3n de proyectos. Este IDE se puede obtener desde aqu\u00ed . Herramientas \u00b6 La interfaz, como se puede observar en la imagen anterior, se compone de un dise\u00f1o b\u00e1sico que cuando es abierto muestra inicialmente los tres paneles siguientes: La consola interactiva de R: situada a la izquierda, permite a los usuarios dar instrucciones mediante comandos de R a alg\u00fan programa inform\u00e1tico por medio de una l\u00ednea de texto. Ambiente e historial: localizado en la esquina superior derecha. Environment incluye las opciones de abrir, guardar e importar el conjunto de datos con los que se podr\u00edan trabajar; buscar y limpiar objetos del \u00e1rea de trabajo, es decir, eliminar las variables definidas en la sesi\u00f3n actual; muestra la informaci\u00f3n de los objetos como lista o cuadr\u00edcula (m\u00e1s detallada); se puede seleccionar la opci\u00f3n global environment , para visualizar los objetos, o package , para consultar funciones. History ofrece el conjunto de \u00f3rdenes que se han llevado a cabo. \u00c9stas pueden ser abiertas de otra sesi\u00f3n o de una nueva, cuyas modificaciones pueden ser salvadas; las opciones To Console y To Source permiten enviar las l\u00edneas seleccionadas a la consola o al editor, respectivamente; el s\u00edmbolo de escoba para eliminar las \u00f3rdenes y el buscador para encontrar aquella que se precise. Barra de herramientas Files/Plots/Packages/Help/Viewer : La solapa Files permite crear carpetas ( New Folder ) y muestra la carpeta donde nos encontramos y su contenido, el cual puede ser eliminado o renombrado ( Delete y Rename ), al igual que se puede copiar o mover, e incluso, definir un nuevo directorio ( More ). La solapa Plots muestra los gr\u00e1ficos que se van generando y ofrece la posibilidad de eliminarlo y otras para salvarlo ( Export ). La solapa Packages ofrece la posibilidad de cargar o instalar la librer\u00eda deseada, cuya b\u00fasqueda se facilita con un buscador, si se conoce previamente, o mediante la descripci\u00f3n. Adem\u00e1s, el hacer click en el nombre del paquete, redirecciona a la solapa Help , donde se amplia la informaci\u00f3n de una forma m\u00e1s detallada, a la cual se puede acceder tambi\u00e9n mediante el buscador de la propia solapa o al solicitar la ayuda desde la consola mediante la funci\u00f3n help(\"\") , o bien ?funci\u00f3n . Por \u00faltimo, la solapa Viewer se puede emplear para visualizar gr\u00e1ficos procedentes de software espec\u00edfico, p\u00e1ginas web u objetos web locales. Por otro lado, RStudio contiene otro tipo de barras de herramientas con diferentes posibilidades. Barra de herramientas general : incluye las opciones de crear un nuevo archivo, abrir uno ya creado, guardar el fichero actual o todos los ficheros abiertos, imprimir, el cuadro de texto Go to file/function ; el icono de paneles que permite configurar a estos, y el bot\u00f3n Addins . Adem\u00e1s, en el extremo derecho se encuentra la opci\u00f3n de abrir un nuevo proyecto, cerrarlo o seleccionar aquel sobre el que se vaya a trabajar. Barra de herramientas del archivo seleccionado : dirigida a los ficheros abiertos, se sit\u00faa justamente encima del panel desplegado cuando se abre un fichero. Las opciones que ofrece son el cambio de fichero de trabajo, mostrar el fichero en una ventana independiente, guardar o ejecutar el script. Otra barra de herramientas fundamental es la barra de men\u00fas situada en la parte superior de la interfaz. Los diferentes men\u00fas que la componen ofrecen una amplia variedad de herramientas para realizar con RStudio: File : permite crear nuevos ficheros de distintos tipos, como R Script, Text File, etc, o abrirlos, al igual que con proyectos. Tambi\u00e9n ofrece la posibilidad de importar conjuntos de datos, guardar ficheros, renombrarlos, observar el borrador o publicarlo. Edit : incluye las opciones generales de copiar, cortar, pegar, deshacer, rehacer, buscar, limpiar, etc. Code : dirigido a la programaci\u00f3n. Es de gran ayuda para ficheros con mucho c\u00f3digo, de forma que se pueda, entre otras cosas, extraer o ejecutar partes espec\u00edficas. View : orientado a la configuraci\u00f3n del entorno, activando o desactivando ciertas opciones que ofrece. Plots : expone distintas acciones a realizar para gr\u00e1ficos, como guardarlo, eliminarlo o navegar entre los distintos gr\u00e1ficos abiertos. Session : permite abrir o cerrar sesi\u00f3n, ambiente e historial. Build : centrado en la construcci\u00f3n de proyectos. Debug : dise\u00f1ado para programaci\u00f3n, ya que ayuda a agilizar o depurar c\u00f3digo, localizando errores o elementos innecesarios. Destaca la opci\u00f3n Toggle Breakpoints , que al correr el c\u00f3digo realiza un punto de parada donde se haya situado, de forma que sea posible la revisi\u00f3n del c\u00f3digo ejecutado. Esto tambi\u00e9n se puede hacer clicando a la izquierda del n\u00famero de la l\u00ednea deseada en c\u00f3digo ejecutable. Profile : encaminado a la optimicaci\u00f3n de memoria y velocidad de programas de R. Tools : ofrece distintas posibilidades como la instalaci\u00f3n o actualizaci\u00f3n de paquetes, acciones sobre el proyecto, configuraci\u00f3n de RStudio, lista de combinaciones de teclas y la funci\u00f3n correspondiente, abrir el terminal, etc. Help : permite acceder a la documentaci\u00f3n de funciones de R o informaci\u00f3n sobre RStudio. Cuadernos de R \u00b6 Los cuadernos de R son documentos R Markdown interactivos, ya que contienen c\u00f3digo ejecutable y comentarios con texto enriquecido. Estos cuadernos son una caracter\u00edstica que tiene RStudio que permiten trabajar con el c\u00f3digo que se pretende incluir en una publicaci\u00f3n de forma directa. El archivo puede ser creado desde File --> New File --> R Notebook de la barra de herramientas general y confiere al estudiante la posibilidad de combinar el c\u00f3digo con texto para producir, por ejemplo, un archivo PDF o Doc de Word, mientras practica con el c\u00f3digo, de este modo podr\u00eda incluir explicaciones seg\u00fan avanza en el dise\u00f1o del programa. La cabecera del archivo suele tener el siguiente dise\u00f1o: 1 2 3 4 5 6 7 8 9 --- title : \"Escribe tu titulo\" author : \"Escribe tu nombre\" date : \"Escribe la fecha\" output : pdf_document : default html_document : default word_document : default --- Para que aparezca el c\u00f3digo R en el documento final es necesario incluir esto: 1 2 3 ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` El c\u00f3digo de R que se pretende publicar se inserta del siguiente modo: 1 2 3 ```{r} escribir c\u00f3digo ``` El texto que intercalamos con el c\u00f3digo R se sit\u00faa fuera de la sentencia anterior y una pincelada b\u00e1sica del formato que se emplea es el siguiente: Negrita y cursiva: aquello que se quiere resaltar se sit\u00faa entre los s\u00edmbolos * y _, siendo doble en caso de negrita. Ejemplos 1 2 3 4 ** Negrita ** __ Negrita__ \\ cursiva \\ _ cursiva_ La cabecera de las secciones se obtiene con el s\u00edmbolo #, repitiendo el s\u00edmbolo si se pretende jerarquizar las secciones. Ejemplos 1 2 3 # Apartado 1 ## Apartado 1.1 ### Apartado 1.1.1. Finalmente, la consecuci\u00f3n del documento final se logra al pinchar en el bot\u00f3n Knit , donde se puede seleccionar el tipo de documento que se desea obtener. Si bien, el formato PDF requiere tener instalado LaTeX en el sistema. Ejemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- title : \"Ra\u00edz cuadrada de un n\u00famero\" author : \"Ismael S\u00e1nchez Pareja\" date : \"Junio 2020\" output : html_document : default html_notebook : default pdf_document : default --- # Enunciado del problema Deseamos calcular la ra\u00edz cuadrada de un numero dado. Puesto que la funcion ra\u00edz cuadrada no esta definida para valores negativos , el programa debe controlar dicha situacion y mostrar un error en tal caso. $$ f ( x ) = \\ sqrt ( x ) $$ # Codigo del programa ```{r} print(\"Introduce un numero\") # x <- scan(n=1) x <- 31 # Valor constante para hacer Knit if (x < 0) { print(\"ERROR: el valor debe ser positivo.\") # Puedes usar stop, pero no va a generar el Knit } else { y <- sqrt(x) cat(\"La ra\u00edz cuadrada de\", x, \"vale\", y, \"\\n\") } ``` Enlaces de inter\u00e9s Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba . R, RStudio y R-Commander: gu\u00eda introductoria. Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez & Jos\u00e9 Diz P\u00e9rez . RMarkdown b\u00e1sico. Tom\u00e1s Goicoa . R Markdown: The Definitive Guide. Yihui Xie, J. J. Allaire, Garrett Grolemund .","title":"RStudio"},{"location":"RStudio/#herramientas","text":"La interfaz, como se puede observar en la imagen anterior, se compone de un dise\u00f1o b\u00e1sico que cuando es abierto muestra inicialmente los tres paneles siguientes: La consola interactiva de R: situada a la izquierda, permite a los usuarios dar instrucciones mediante comandos de R a alg\u00fan programa inform\u00e1tico por medio de una l\u00ednea de texto. Ambiente e historial: localizado en la esquina superior derecha. Environment incluye las opciones de abrir, guardar e importar el conjunto de datos con los que se podr\u00edan trabajar; buscar y limpiar objetos del \u00e1rea de trabajo, es decir, eliminar las variables definidas en la sesi\u00f3n actual; muestra la informaci\u00f3n de los objetos como lista o cuadr\u00edcula (m\u00e1s detallada); se puede seleccionar la opci\u00f3n global environment , para visualizar los objetos, o package , para consultar funciones. History ofrece el conjunto de \u00f3rdenes que se han llevado a cabo. \u00c9stas pueden ser abiertas de otra sesi\u00f3n o de una nueva, cuyas modificaciones pueden ser salvadas; las opciones To Console y To Source permiten enviar las l\u00edneas seleccionadas a la consola o al editor, respectivamente; el s\u00edmbolo de escoba para eliminar las \u00f3rdenes y el buscador para encontrar aquella que se precise. Barra de herramientas Files/Plots/Packages/Help/Viewer : La solapa Files permite crear carpetas ( New Folder ) y muestra la carpeta donde nos encontramos y su contenido, el cual puede ser eliminado o renombrado ( Delete y Rename ), al igual que se puede copiar o mover, e incluso, definir un nuevo directorio ( More ). La solapa Plots muestra los gr\u00e1ficos que se van generando y ofrece la posibilidad de eliminarlo y otras para salvarlo ( Export ). La solapa Packages ofrece la posibilidad de cargar o instalar la librer\u00eda deseada, cuya b\u00fasqueda se facilita con un buscador, si se conoce previamente, o mediante la descripci\u00f3n. Adem\u00e1s, el hacer click en el nombre del paquete, redirecciona a la solapa Help , donde se amplia la informaci\u00f3n de una forma m\u00e1s detallada, a la cual se puede acceder tambi\u00e9n mediante el buscador de la propia solapa o al solicitar la ayuda desde la consola mediante la funci\u00f3n help(\"\") , o bien ?funci\u00f3n . Por \u00faltimo, la solapa Viewer se puede emplear para visualizar gr\u00e1ficos procedentes de software espec\u00edfico, p\u00e1ginas web u objetos web locales. Por otro lado, RStudio contiene otro tipo de barras de herramientas con diferentes posibilidades. Barra de herramientas general : incluye las opciones de crear un nuevo archivo, abrir uno ya creado, guardar el fichero actual o todos los ficheros abiertos, imprimir, el cuadro de texto Go to file/function ; el icono de paneles que permite configurar a estos, y el bot\u00f3n Addins . Adem\u00e1s, en el extremo derecho se encuentra la opci\u00f3n de abrir un nuevo proyecto, cerrarlo o seleccionar aquel sobre el que se vaya a trabajar. Barra de herramientas del archivo seleccionado : dirigida a los ficheros abiertos, se sit\u00faa justamente encima del panel desplegado cuando se abre un fichero. Las opciones que ofrece son el cambio de fichero de trabajo, mostrar el fichero en una ventana independiente, guardar o ejecutar el script. Otra barra de herramientas fundamental es la barra de men\u00fas situada en la parte superior de la interfaz. Los diferentes men\u00fas que la componen ofrecen una amplia variedad de herramientas para realizar con RStudio: File : permite crear nuevos ficheros de distintos tipos, como R Script, Text File, etc, o abrirlos, al igual que con proyectos. Tambi\u00e9n ofrece la posibilidad de importar conjuntos de datos, guardar ficheros, renombrarlos, observar el borrador o publicarlo. Edit : incluye las opciones generales de copiar, cortar, pegar, deshacer, rehacer, buscar, limpiar, etc. Code : dirigido a la programaci\u00f3n. Es de gran ayuda para ficheros con mucho c\u00f3digo, de forma que se pueda, entre otras cosas, extraer o ejecutar partes espec\u00edficas. View : orientado a la configuraci\u00f3n del entorno, activando o desactivando ciertas opciones que ofrece. Plots : expone distintas acciones a realizar para gr\u00e1ficos, como guardarlo, eliminarlo o navegar entre los distintos gr\u00e1ficos abiertos. Session : permite abrir o cerrar sesi\u00f3n, ambiente e historial. Build : centrado en la construcci\u00f3n de proyectos. Debug : dise\u00f1ado para programaci\u00f3n, ya que ayuda a agilizar o depurar c\u00f3digo, localizando errores o elementos innecesarios. Destaca la opci\u00f3n Toggle Breakpoints , que al correr el c\u00f3digo realiza un punto de parada donde se haya situado, de forma que sea posible la revisi\u00f3n del c\u00f3digo ejecutado. Esto tambi\u00e9n se puede hacer clicando a la izquierda del n\u00famero de la l\u00ednea deseada en c\u00f3digo ejecutable. Profile : encaminado a la optimicaci\u00f3n de memoria y velocidad de programas de R. Tools : ofrece distintas posibilidades como la instalaci\u00f3n o actualizaci\u00f3n de paquetes, acciones sobre el proyecto, configuraci\u00f3n de RStudio, lista de combinaciones de teclas y la funci\u00f3n correspondiente, abrir el terminal, etc. Help : permite acceder a la documentaci\u00f3n de funciones de R o informaci\u00f3n sobre RStudio.","title":"Herramientas"},{"location":"RStudio/#cuadernos-de-r","text":"Los cuadernos de R son documentos R Markdown interactivos, ya que contienen c\u00f3digo ejecutable y comentarios con texto enriquecido. Estos cuadernos son una caracter\u00edstica que tiene RStudio que permiten trabajar con el c\u00f3digo que se pretende incluir en una publicaci\u00f3n de forma directa. El archivo puede ser creado desde File --> New File --> R Notebook de la barra de herramientas general y confiere al estudiante la posibilidad de combinar el c\u00f3digo con texto para producir, por ejemplo, un archivo PDF o Doc de Word, mientras practica con el c\u00f3digo, de este modo podr\u00eda incluir explicaciones seg\u00fan avanza en el dise\u00f1o del programa. La cabecera del archivo suele tener el siguiente dise\u00f1o: 1 2 3 4 5 6 7 8 9 --- title : \"Escribe tu titulo\" author : \"Escribe tu nombre\" date : \"Escribe la fecha\" output : pdf_document : default html_document : default word_document : default --- Para que aparezca el c\u00f3digo R en el documento final es necesario incluir esto: 1 2 3 ```{r setup, include=FALSE} knitr::opts_chunk$set(echo = TRUE) ``` El c\u00f3digo de R que se pretende publicar se inserta del siguiente modo: 1 2 3 ```{r} escribir c\u00f3digo ``` El texto que intercalamos con el c\u00f3digo R se sit\u00faa fuera de la sentencia anterior y una pincelada b\u00e1sica del formato que se emplea es el siguiente: Negrita y cursiva: aquello que se quiere resaltar se sit\u00faa entre los s\u00edmbolos * y _, siendo doble en caso de negrita. Ejemplos 1 2 3 4 ** Negrita ** __ Negrita__ \\ cursiva \\ _ cursiva_ La cabecera de las secciones se obtiene con el s\u00edmbolo #, repitiendo el s\u00edmbolo si se pretende jerarquizar las secciones. Ejemplos 1 2 3 # Apartado 1 ## Apartado 1.1 ### Apartado 1.1.1. Finalmente, la consecuci\u00f3n del documento final se logra al pinchar en el bot\u00f3n Knit , donde se puede seleccionar el tipo de documento que se desea obtener. Si bien, el formato PDF requiere tener instalado LaTeX en el sistema. Ejemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 --- title : \"Ra\u00edz cuadrada de un n\u00famero\" author : \"Ismael S\u00e1nchez Pareja\" date : \"Junio 2020\" output : html_document : default html_notebook : default pdf_document : default --- # Enunciado del problema Deseamos calcular la ra\u00edz cuadrada de un numero dado. Puesto que la funcion ra\u00edz cuadrada no esta definida para valores negativos , el programa debe controlar dicha situacion y mostrar un error en tal caso. $$ f ( x ) = \\ sqrt ( x ) $$ # Codigo del programa ```{r} print(\"Introduce un numero\") # x <- scan(n=1) x <- 31 # Valor constante para hacer Knit if (x < 0) { print(\"ERROR: el valor debe ser positivo.\") # Puedes usar stop, pero no va a generar el Knit } else { y <- sqrt(x) cat(\"La ra\u00edz cuadrada de\", x, \"vale\", y, \"\\n\") } ``` Enlaces de inter\u00e9s Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba . R, RStudio y R-Commander: gu\u00eda introductoria. Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez & Jos\u00e9 Diz P\u00e9rez . RMarkdown b\u00e1sico. Tom\u00e1s Goicoa . R Markdown: The Definitive Guide. Yihui Xie, J. J. Allaire, Garrett Grolemund .","title":"Cuadernos de R"},{"location":"acercade/","text":"La versi\u00f3n inicial de este Tutorial de Programaci\u00f3n en R ha sido desarrollada como Trabajo Fin de Grado de la titulaci\u00f3n Grado en Bioqu\u00edmica , en la Universidad de C\u00f3rdoba , por el alumno Ismael S\u00e1nchez Pareja , y dirigida por el profesor Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez .","title":"Acerca de"},{"location":"cadenas/","text":"Las cadenas de caracteres, como se introdujo en Variables, objetos at\u00f3micos y operadores , son una secuencia de caracteres cuya creaci\u00f3n necesita que sean introducidos entre comillas. A continuaci\u00f3n, se explica el tratamiento de estas cadenas y, para ello, se requiere el paquete stringr , el cual est\u00e1 contenido en la biblioteca tidyverse instalada en Conceptos b\u00e1sicos , donde tambi\u00e9n se indica c\u00f3mo se carga una biblioteca ( library() ). Creaci\u00f3n de cadenas con elementos funcionales \u00b6 Las comillas para crear las cadenas de caracteres suelen ser dobles aunque, si se quiere introducir dicho s\u00edmbolo como elemento de la cadena, se emplean comillas simples. Otro modo de incorporarlas ser\u00eda incluyendo una barra invertida (\\). Esto tambi\u00e9n se puede aplicar en el caso contrario, cuando se utilizan las comillas simples y se quiere introducir dicho s\u00edmbolo tambi\u00e9n como elemento. La barra invertida es utilizada entre otras cosas para indicar, por ejemplo, saltos de l\u00ednea o tabulaci\u00f3n de la siguiente forma, respectivamente: \\n y \\t. Cuando aparecen elementos que realizan funciones como el salto de l\u00ednea, el vector lo interpreta como caracter, aunque se puede ignorar mediante la funci\u00f3n writeLines() . Ejemplos 1 2 3 4 cadena1 <- \"Cadena realizada por estas comillas: \\\", apreciables como elemento gracias a \\\\\" writeLines ( cadena1 ) cadena2 <- c ( \"cadena1\" , \"\\n\" , \"cadena2\" ) writeLines ( cadena2 ) Manipulaci\u00f3n de cadenas \u00b6 El paquete stringr contiene diversas funciones que tambi\u00e9n podr\u00edan llevarse a cabo con funciones de la biblioteca base que se incluye de forma predeterminada en la instalaci\u00f3n de R. Mostramos algunas de ellas en la siguiente tabla: base stringr Funci\u00f3n nchar() str_length() Tama\u00f1o de la cadena gsub() str_replace() Reemplaza un elemento por otro strsplit() str_split() Devuelve una lista con los componentes separados de la cadena Ejemplo 1 2 3 4 5 6 7 8 library ( \"stringr\" ) tama\u00f1o_cadena1A <- nchar ( cadena1 ) tama\u00f1o_cadena1B <- nchar ( cadena1 ) cadena1_reemplA <- gsub ( \"por\" , \"con\" , cadena1 ) cadena1_reemplB <- str_replace ( cadena1 , \"por\" , \"con\" ) cadena1_reempl_all <- str_replace_all ( cadena1 , c ( \"por\" = \"con\" , \"estas\" = \"\" )) cadena1_sepA <- strsplit ( cadena1 , \" \" ) cadena1_sepB <- str_split ( cadena1 , \" \" , simplify = TRUE ) Info La funci\u00f3n str_replace_all() permite realizar m\u00faltiples reemplazos. La funci\u00f3n str_split() ofrece la posibilidad de devolver una matriz aplicando el argumento simplify = TRUE . Cree un script llamado num_simbolos.R que cuente los s\u00edmbolos de una frase. Respuesta 1 2 3 4 frase <- readline ( prompt = \"Indique la frase: \" ) split_frase <- gsub ( \" \" , \"\" , frase ) num_simbolos <- nchar ( split_frase ) cat ( \"La frase contiene\" , num_letras , \"s\u00edmbolos.\" ) La biblioteca stringr posee una gran cantidad de funciones interesantes adem\u00e1s de las mencionadas anteriormente. A continuaci\u00f3n, se muestran varias de ellas: stringr Funci\u00f3n str_c() Combina cadenas str_sub() Extrae partes de cadenas str_extract() Extrae partes de cadenas str_to_upper() Cambia cadenas a may\u00fascula str_to_lower() Cambia cadenas a min\u00fascula str_sort() Ordena cadenas por alfabeto str_detect() Detecta coincidencias str_count() Indica el n\u00famero de coincidencias Ejemplos 1 2 3 4 5 6 7 8 9 cadena_1_2 <- str_c ( cadena1 , cadena2 , sep = \"; \" ) cadena1_sub <- str_sub ( cadena1 , 1 , 6 ) cadena1_extr <- str_extract ( cadena1 , \"cadena\" ) cadena1_extr_all <- str_extract_all ( cadena1 , \"\" ) cadena_up <- str_to_upper ( cadena1_sub ) cadena_low <- str_to_lower ( cadena_up ) dna_sort <- str_sort ( c ( \"D\" , \"N\" , \"A\" )) A_dna_detect <- str_detect ( dna_sort , \"A\" ) num_A_dna_detect <- str_count ( dna_sort , \"A\" ) Info La funci\u00f3n str_extract_all() permite realizar extracciones distintas y devuelve una lista o, mediante el argumento simplify=TRUE , una matriz. Cree un script llamado ordenagente.R que devuelva los nombres de un grupo de gente ordenados y en may\u00fascula. Respuesta 1 2 3 4 5 6 7 8 9 10 library ( \"stringr\" ) print ( \"\u00bfCu\u00e1ntas personas engloba el grupo? \" ) n_gente <- scan ( n = 1 ) v_gente1 <- 2 : n_gente v_gente2 <- readline ( prompt = \"Indique un integrante: \" ) for ( i in v_gente1 ){ v_gente2 [ i ] <- readline ( prompt = \"Indique otro integrante: \" ) } sort_up_gente <- str_sort ( str_to_upper ( v_gente2 )) print ( sort_up_gente ) Ejercicios complementarios \u00b6 Cree un script llamado adn_a_arn_codones.R que devuelva el transcrito que se obtendr\u00eda de una secuencia de ADN determinada y la divisi\u00f3n en codones. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library ( \"stringr\" ) adn <- readline ( prompt = \"Introduzca la secuencia de ADN: \" ) arn <- str_replace_all ( adn , c ( \"A\" = \"U\" , \"T\" = \"A\" , \"G\" = \"c\" , \"C\" = \"G\" )) arn <- str_to_upper ( arn ) cat ( \"ARN:\" , arn ) codones <- c () ncodones <- nchar ( arn ) / 3 + 1 aa <- 1 ab <- 3 for ( i in 1 : ncodones ){ codones [ i ] <- str_sub ( arn , aa , ab ) ab <- ab + 3 aa <- aa + 3 } cat ( \"Codones:\" , codones ) Cree un script llamado tabla_nucleotidos.R que devuelva la cantidad de nucle\u00f3tidos como tabla. Respuesta 1 2 3 4 5 6 7 8 9 10 11 library ( \"stringr\" ) adn <- readline ( prompt = \"Introduzca la secuencia de ADN: \" ) cadena <- strsplit ( adn , \"\" ) nucleotidos <- sort ( unique ( cadena )) histo <- matrix ( 0 , 1 , length ( nucleotidos )) for ( i in 1 : length ( nucleotidos )){ histo [ i ] <- str_count ( adn , nucleotidos [ i ]) } colnames ( histo ) <- nucleotidos rownames ( histo ) <- \"cantidad\" print ( histo ) Ejercicio resumen El siguiente archivo .Rmd contiene un ejercicio de manipulaci\u00f3n de una cadena procedente de un archivo FASTA ( FASTA File ), de modo que resuma de forma explicativa lo estudiado en este apartado, por lo que requiere la instalaci\u00f3n de la biblioteca tidyverse : cadenas_fasta.Rmd . El archivo FASTA es el mismo cuya descarga es utilizada como ejemplo de descarga de ficheros en R en Conceptos b\u00e1sicos , por tanto podr\u00eda acceder a dicho archivo de ambas formas. Enlaces de inter\u00e9s R for Data Science. Garrett Grolemund & Hadley Wickham. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Cadenas de caracteres"},{"location":"cadenas/#creacion-de-cadenas-con-elementos-funcionales","text":"Las comillas para crear las cadenas de caracteres suelen ser dobles aunque, si se quiere introducir dicho s\u00edmbolo como elemento de la cadena, se emplean comillas simples. Otro modo de incorporarlas ser\u00eda incluyendo una barra invertida (\\). Esto tambi\u00e9n se puede aplicar en el caso contrario, cuando se utilizan las comillas simples y se quiere introducir dicho s\u00edmbolo tambi\u00e9n como elemento. La barra invertida es utilizada entre otras cosas para indicar, por ejemplo, saltos de l\u00ednea o tabulaci\u00f3n de la siguiente forma, respectivamente: \\n y \\t. Cuando aparecen elementos que realizan funciones como el salto de l\u00ednea, el vector lo interpreta como caracter, aunque se puede ignorar mediante la funci\u00f3n writeLines() . Ejemplos 1 2 3 4 cadena1 <- \"Cadena realizada por estas comillas: \\\", apreciables como elemento gracias a \\\\\" writeLines ( cadena1 ) cadena2 <- c ( \"cadena1\" , \"\\n\" , \"cadena2\" ) writeLines ( cadena2 )","title":"Creaci\u00f3n de cadenas con elementos funcionales"},{"location":"cadenas/#manipulacion-de-cadenas","text":"El paquete stringr contiene diversas funciones que tambi\u00e9n podr\u00edan llevarse a cabo con funciones de la biblioteca base que se incluye de forma predeterminada en la instalaci\u00f3n de R. Mostramos algunas de ellas en la siguiente tabla: base stringr Funci\u00f3n nchar() str_length() Tama\u00f1o de la cadena gsub() str_replace() Reemplaza un elemento por otro strsplit() str_split() Devuelve una lista con los componentes separados de la cadena Ejemplo 1 2 3 4 5 6 7 8 library ( \"stringr\" ) tama\u00f1o_cadena1A <- nchar ( cadena1 ) tama\u00f1o_cadena1B <- nchar ( cadena1 ) cadena1_reemplA <- gsub ( \"por\" , \"con\" , cadena1 ) cadena1_reemplB <- str_replace ( cadena1 , \"por\" , \"con\" ) cadena1_reempl_all <- str_replace_all ( cadena1 , c ( \"por\" = \"con\" , \"estas\" = \"\" )) cadena1_sepA <- strsplit ( cadena1 , \" \" ) cadena1_sepB <- str_split ( cadena1 , \" \" , simplify = TRUE ) Info La funci\u00f3n str_replace_all() permite realizar m\u00faltiples reemplazos. La funci\u00f3n str_split() ofrece la posibilidad de devolver una matriz aplicando el argumento simplify = TRUE . Cree un script llamado num_simbolos.R que cuente los s\u00edmbolos de una frase. Respuesta 1 2 3 4 frase <- readline ( prompt = \"Indique la frase: \" ) split_frase <- gsub ( \" \" , \"\" , frase ) num_simbolos <- nchar ( split_frase ) cat ( \"La frase contiene\" , num_letras , \"s\u00edmbolos.\" ) La biblioteca stringr posee una gran cantidad de funciones interesantes adem\u00e1s de las mencionadas anteriormente. A continuaci\u00f3n, se muestran varias de ellas: stringr Funci\u00f3n str_c() Combina cadenas str_sub() Extrae partes de cadenas str_extract() Extrae partes de cadenas str_to_upper() Cambia cadenas a may\u00fascula str_to_lower() Cambia cadenas a min\u00fascula str_sort() Ordena cadenas por alfabeto str_detect() Detecta coincidencias str_count() Indica el n\u00famero de coincidencias Ejemplos 1 2 3 4 5 6 7 8 9 cadena_1_2 <- str_c ( cadena1 , cadena2 , sep = \"; \" ) cadena1_sub <- str_sub ( cadena1 , 1 , 6 ) cadena1_extr <- str_extract ( cadena1 , \"cadena\" ) cadena1_extr_all <- str_extract_all ( cadena1 , \"\" ) cadena_up <- str_to_upper ( cadena1_sub ) cadena_low <- str_to_lower ( cadena_up ) dna_sort <- str_sort ( c ( \"D\" , \"N\" , \"A\" )) A_dna_detect <- str_detect ( dna_sort , \"A\" ) num_A_dna_detect <- str_count ( dna_sort , \"A\" ) Info La funci\u00f3n str_extract_all() permite realizar extracciones distintas y devuelve una lista o, mediante el argumento simplify=TRUE , una matriz. Cree un script llamado ordenagente.R que devuelva los nombres de un grupo de gente ordenados y en may\u00fascula. Respuesta 1 2 3 4 5 6 7 8 9 10 library ( \"stringr\" ) print ( \"\u00bfCu\u00e1ntas personas engloba el grupo? \" ) n_gente <- scan ( n = 1 ) v_gente1 <- 2 : n_gente v_gente2 <- readline ( prompt = \"Indique un integrante: \" ) for ( i in v_gente1 ){ v_gente2 [ i ] <- readline ( prompt = \"Indique otro integrante: \" ) } sort_up_gente <- str_sort ( str_to_upper ( v_gente2 )) print ( sort_up_gente )","title":"Manipulaci\u00f3n de cadenas"},{"location":"cadenas/#ejercicios-complementarios","text":"Cree un script llamado adn_a_arn_codones.R que devuelva el transcrito que se obtendr\u00eda de una secuencia de ADN determinada y la divisi\u00f3n en codones. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 library ( \"stringr\" ) adn <- readline ( prompt = \"Introduzca la secuencia de ADN: \" ) arn <- str_replace_all ( adn , c ( \"A\" = \"U\" , \"T\" = \"A\" , \"G\" = \"c\" , \"C\" = \"G\" )) arn <- str_to_upper ( arn ) cat ( \"ARN:\" , arn ) codones <- c () ncodones <- nchar ( arn ) / 3 + 1 aa <- 1 ab <- 3 for ( i in 1 : ncodones ){ codones [ i ] <- str_sub ( arn , aa , ab ) ab <- ab + 3 aa <- aa + 3 } cat ( \"Codones:\" , codones ) Cree un script llamado tabla_nucleotidos.R que devuelva la cantidad de nucle\u00f3tidos como tabla. Respuesta 1 2 3 4 5 6 7 8 9 10 11 library ( \"stringr\" ) adn <- readline ( prompt = \"Introduzca la secuencia de ADN: \" ) cadena <- strsplit ( adn , \"\" ) nucleotidos <- sort ( unique ( cadena )) histo <- matrix ( 0 , 1 , length ( nucleotidos )) for ( i in 1 : length ( nucleotidos )){ histo [ i ] <- str_count ( adn , nucleotidos [ i ]) } colnames ( histo ) <- nucleotidos rownames ( histo ) <- \"cantidad\" print ( histo ) Ejercicio resumen El siguiente archivo .Rmd contiene un ejercicio de manipulaci\u00f3n de una cadena procedente de un archivo FASTA ( FASTA File ), de modo que resuma de forma explicativa lo estudiado en este apartado, por lo que requiere la instalaci\u00f3n de la biblioteca tidyverse : cadenas_fasta.Rmd . El archivo FASTA es el mismo cuya descarga es utilizada como ejemplo de descarga de ficheros en R en Conceptos b\u00e1sicos , por tanto podr\u00eda acceder a dicho archivo de ambas formas. Enlaces de inter\u00e9s R for Data Science. Garrett Grolemund & Hadley Wickham. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Ejercicios complementarios"},{"location":"conceptos_basicos/","text":"Iniciaci\u00f3n en el terminal y R \u00b6 R puede ejecutarse desde la terminal o s\u00edmbolo del sistema de nuestro sistema operativo, que se puede abrir en Linux tecleando secuencialmente ctrl + alt + t o, como en cualquier sistema operativo, tras una simple b\u00fasqueda en el sistema. La forma de abrir una sesi\u00f3n de R en la terminal es introduciendo el comando R en el prompt , es decir, el car\u00e1cter o conjunto de caracteres, generalmente > , en Windows, o ~$ , en Linux, y un cursor parpadeante, que se muestran en una l\u00ednea de comandos para indicar que est\u00e1 a la espera de \u00f3rdenes. Para salir de la sesi\u00f3n de R y volver al terminal de Linux debes indicar la orden >q() . Otro modo de recurrir al lenguaje de programaci\u00f3n R ser\u00eda ejecutando R -q \u2013-vanilla -e 'orden deseada' . No obstante, es frecuente el empleo de un entorno de desarrollo integrado (IDE) o interfaz que facilite su uso, como RStudio . Cabe mencionar que cuando se est\u00e1 llevando a cabo una operaci\u00f3n con R y se pretende abandonar su acci\u00f3n antes de que finalice, se presiona la tecla ESC , si est\u00e1s en RStudio, o ctrl + c , para la terminal. Todo aquello que es creado en una sesi\u00f3n de R permanece s\u00f3lo en ella, es decir, no es compartido entre sesiones, aunque se encuentren activas simult\u00e1neamente o se sit\u00faen en el mismo directorio, t\u00e9rmino extendido coloquialmente como carpeta de trabajo o archivos. El hecho de saber el directorio donde se encuentra la l\u00ednea de comandos es imprescindible, ya que se trabaja a partir de \u00e9ste, a no ser que se indique lo contrario. Para ello, ha de ejecutarse getwd() . Si se desea cambiar de directorio, se ejecutar\u00eda setwd() . Dicho esto, se recomienda practicar este tutorial siempre en el mismo directorio. La forma de crear un directorio desde R en la ruta donde se encuentra es mediante dir.create() . En cambio, si se quiere eliminar alg\u00fan archivo ser\u00eda a trav\u00e9s de file.remove() . Si optas por cambiar de nombre el archivo, puede aplicar file.rename() , indicando primeramente el archivo y seguidamente el nombre nuevo. Para conocer los archivos o los subdirectorios del directorio donde se encuentra abierta la sesi\u00f3n, se ejecuta list.files() y list.dirs() , de forma respectiva. En cambio, si se pretende descubrir los elementos que contiene nuestra sesi\u00f3n se ejecuta ls() , que muestra una lista con los nombres de todo lo que ha sido guardado durante ella. De hecho, cuando se cierra la sesi\u00f3n de R, se pregunta si se desea guardar el contenido creado en ella para recurrir a \u00e9ste en otras ocasiones, generando y actualizando un archivo con extensi\u00f3n .Rdata en el directorio de trabajo. Las distintas opciones mencionadas requieren incluir entre comillas la ruta donde se pretende hacer la modificaci\u00f3n. \u00a1Es tu momento! Abre una sesi\u00f3n de R, dir\u00edgete hacia el directorio que desees, cre\u00e1ndolo o renombr\u00e1ndolo si fuese necesario, y comprueba su contenido antes de finalizar la sesi\u00f3n. Ejemplo 1 2 3 4 5 6 7 8 R getwd () dir.create ( \"tutorial\" ) list.dirs () file.rename ( \"tutorial\" , \"biotutorialR\" ) setwd ( \"biotutorialR\" ) list.files () q () Info Estas acciones pueden realizarse desde la terminal sin necesidad de llevarlas a cabo en una sesi\u00f3n de R. Los comandos ser\u00edan los siguientes: Comando Funci\u00f3n pwd Localizar el directorio donde se encuentra ls Visualizar su contenido cd ruta Cambiar de directorio mkdir nombre Crear un directorio rm -r nombre Borrar directorio y su contenido Vocabulario b\u00e1sico \u00b6 En programaci\u00f3n se emplea una jerga que a principiantes podr\u00eda resultar dificultoso su entendimiento. Un ejemplo que debe ser conocido antes de profundizar en la materia es el uso de los verbos llamar , correr y ejecutar , los cuales son referidos para que el lenguaje que se est\u00e9 utilizando realice una acci\u00f3n con la instrucci\u00f3n o entrada (\"input\") que se mencione. A partir de ella, se genera una salida (\"output\") que ser\u00eda el resultado de la operaci\u00f3n, para lo que se utiliza el verbo devolver . En ocasiones, un segmento de c\u00f3digo se repite, lo que se conoce como iteraci\u00f3n . Hay que tener en cuenta el s\u00edmbolo # , conocido como corchete o \"hashtag\", el cual suele introducirse en funciones para incluir comentarios del c\u00f3digo y que no sean ejecutados. Funciones y ayuda \u00b6 Las operaciones a ejecutar, junto a ciertas especificaciones denominadas argumento , se pueden asignar a un nombre, lo que se llama funci\u00f3n , la cual realiza las operaciones que contiene cuando se llama, por lo que se recomienda que su nombre represente o describa significativamente las operaciones, para que no surjan dudas de su acci\u00f3n. Las funciones se muestran de la siguiente forma: nombre_funci\u00f3n() . Existen ciertas funciones b\u00e1sicas que R reconoce desde un principio, como el c\u00e1lculo de la media, el cuantil y el tama\u00f1o o longitud de un objeto. Como se ha dicho, los nombres son descriptivos, por lo que las operaciones que lleva a cabo se deducen a simple vista, pero cuando se est\u00e1 indeciso sobre ellas, se puede recurrir a su documentaci\u00f3n, ya que todas las funciones tienen uno de estos archivos que describe lo que realiza la funci\u00f3n y detalles sobre sus argumentos, las operaciones y los resultados que devuelve, e incluye ejemplos de uso. La forma de acudir a este documento es situando el nombre dentro de la funci\u00f3n help() o escribiendo el operador interrogativo ? antes de su nombre. Si se utilizan en la terminal, para abandonar la documentaci\u00f3n se pulsa \u2191 + q . \u00bfQu\u00e9 operaciones realizar\u00edan las funciones mean() , quantile() , length() , summary() y sd() ? Respuesta Las tres primeras se han mencionado anteriormente como funciones b\u00e1sicas en el mismo orden que se preguntan, aunque si no se est\u00e1 seguro se puede recurrir a su documentaci\u00f3n. summary() y sd() podr\u00edan llevar a duda, por lo que se van a utilizar como ejemplo de acceso a documentaci\u00f3n. 1 2 help ( summary ) ? sd () Bibliotecas \u00b6 Las funciones pueden estar contenidas en paquetes , es decir, colecciones de funciones dise\u00f1adas para realizar tareas espec\u00edficas, como podr\u00eda ser alineamiento gen\u00f3mico o an\u00e1lisis de expresi\u00f3n gen\u00e9tica. Estos paquetes se encuentran disponibles en repositorios como bioconductor , el cual proporciona herramientas para el \u00e1mbito de la bioinform\u00e1tica e investigaci\u00f3n biom\u00e9dica. La forma de acceder a las funciones de estos paquetes es a trav\u00e9s de la funci\u00f3n library() , la cual se debe llamar cada vez que se inicie sesi\u00f3n en R. Para que reconozca el paquete de funciones, \u00e9ste deber\u00eda ser instalado previamente mediante la funci\u00f3n install.packages() . Otras funciones como installed.packages() y sessionInfo() permiten conocer qu\u00e9 paquetes est\u00e1n instalados en el sistema y cu\u00e1les est\u00e1n activos en la sesi\u00f3n abierta, respectivamente. Si se quiere actualizar un paquete ya instalado, se emplea la funci\u00f3n update.packages() . Todas estas funciones requieren indicar el paquete entre comillas. Comprueba si tienes instalados y actualizados las bibliotecas graphics y tidyverse . Si no fuese as\u00ed, intenta instalarlas, ya que ser\u00e1n utilizadas durante el tutorial. Accede al paquete stringr de tidyverse . M\u00e9todo 1 2 3 4 sessionInfo () update.packages ( \"graphics\" ) install.packages ( \"tidyverse\" ) library ( \"stringr\" ) Descarga de ficheros \u00b6 En una sesi\u00f3n de R se pueden descargar archivos mediante la funci\u00f3n download.file() , indicando en el argumento url la direcci\u00f3n de internet donde se encuentra el archivo que se pretende descargar, y en destfile el nombre con el que se quiera guardar el archivo en el ordenador, ambos entre comillas. Ejemplo 1 download.file ( url = \"https://www.ncbi.nlm.nih.gov/sviewer/viewer.cgi?tool=portal&save=file&log$=seqview&db=nuccore&report=fasta&id=973795115&extrafeat=null&conwithfeat=on&\" , destfile = \"prueba.fasta\" ) Scripts en R \u00b6 Un script es un archivo que inicialmente se puede crear con un editor de texto plano como gedit en Linux, o como notepad en Windows, y se guarda con la extensi\u00f3n .R . \u00c9ste puede ser ejecutado en R usando la funci\u00f3n source() , incluyendo la ruta del archivo entre comillas. Com\u00fanmente, el script incluye en su inicio la llamada a paquetes ( library() ) que el usuario podr\u00eda no tener instalados. Para que se muestre directamente alg\u00fan elemento del script, se debe incluir una funci\u00f3n de salida como print() , la cual devuelve el elemento que se introduzca en ella, o cat() , con la que se puede devolver un conjunto de elementos de forma secuencial. Adem\u00e1s, los scripts suelen utilizarse para operar con elementos que elige el usuario. El modo de pedir un \"input\" es incluyendo en el c\u00f3digo del script una funci\u00f3n de entrada como scan() , para n\u00fameros reales, o readline() , para caracteres, y asignarlos a una variable. Ejemplo 1 2 3 4 x <- readline ( prompt = \"Indique su nombre: \" ) print ( \"\u00bfQu\u00e9 edad tiene?\" ) y <- scan ( n = 1 ) cat ( x , \"tiene\" , y , \"a\u00f1os.\" ) Info La funci\u00f3n scan() permite indicar entre el par\u00e9ntesis el n\u00famero de entradas que podr\u00edas realizar. En caso de no hacerlo, podrias llevar a cabo las entradas que desees hasta que introduzcas una entrada vac\u00eda, finalizando el proceso de esta funci\u00f3n. La funci\u00f3n cat() no permite incluir ciertas estructuras de control como argumento, por ejemplo, las listas. \u00bfC\u00f3mo mostrar\u00edas el mensaje \"\u00a1Hola Mundo!\" por la pantalla? Respuesta 1 2 print ( \"\u00a1Hola Mundo!\" ) cat ( \"\u00a1Hola Mundo!\\n\" ) Enlaces de inter\u00e9s R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Conceptos b\u00e1sicos"},{"location":"conceptos_basicos/#iniciacion-en-el-terminal-y-r","text":"R puede ejecutarse desde la terminal o s\u00edmbolo del sistema de nuestro sistema operativo, que se puede abrir en Linux tecleando secuencialmente ctrl + alt + t o, como en cualquier sistema operativo, tras una simple b\u00fasqueda en el sistema. La forma de abrir una sesi\u00f3n de R en la terminal es introduciendo el comando R en el prompt , es decir, el car\u00e1cter o conjunto de caracteres, generalmente > , en Windows, o ~$ , en Linux, y un cursor parpadeante, que se muestran en una l\u00ednea de comandos para indicar que est\u00e1 a la espera de \u00f3rdenes. Para salir de la sesi\u00f3n de R y volver al terminal de Linux debes indicar la orden >q() . Otro modo de recurrir al lenguaje de programaci\u00f3n R ser\u00eda ejecutando R -q \u2013-vanilla -e 'orden deseada' . No obstante, es frecuente el empleo de un entorno de desarrollo integrado (IDE) o interfaz que facilite su uso, como RStudio . Cabe mencionar que cuando se est\u00e1 llevando a cabo una operaci\u00f3n con R y se pretende abandonar su acci\u00f3n antes de que finalice, se presiona la tecla ESC , si est\u00e1s en RStudio, o ctrl + c , para la terminal. Todo aquello que es creado en una sesi\u00f3n de R permanece s\u00f3lo en ella, es decir, no es compartido entre sesiones, aunque se encuentren activas simult\u00e1neamente o se sit\u00faen en el mismo directorio, t\u00e9rmino extendido coloquialmente como carpeta de trabajo o archivos. El hecho de saber el directorio donde se encuentra la l\u00ednea de comandos es imprescindible, ya que se trabaja a partir de \u00e9ste, a no ser que se indique lo contrario. Para ello, ha de ejecutarse getwd() . Si se desea cambiar de directorio, se ejecutar\u00eda setwd() . Dicho esto, se recomienda practicar este tutorial siempre en el mismo directorio. La forma de crear un directorio desde R en la ruta donde se encuentra es mediante dir.create() . En cambio, si se quiere eliminar alg\u00fan archivo ser\u00eda a trav\u00e9s de file.remove() . Si optas por cambiar de nombre el archivo, puede aplicar file.rename() , indicando primeramente el archivo y seguidamente el nombre nuevo. Para conocer los archivos o los subdirectorios del directorio donde se encuentra abierta la sesi\u00f3n, se ejecuta list.files() y list.dirs() , de forma respectiva. En cambio, si se pretende descubrir los elementos que contiene nuestra sesi\u00f3n se ejecuta ls() , que muestra una lista con los nombres de todo lo que ha sido guardado durante ella. De hecho, cuando se cierra la sesi\u00f3n de R, se pregunta si se desea guardar el contenido creado en ella para recurrir a \u00e9ste en otras ocasiones, generando y actualizando un archivo con extensi\u00f3n .Rdata en el directorio de trabajo. Las distintas opciones mencionadas requieren incluir entre comillas la ruta donde se pretende hacer la modificaci\u00f3n. \u00a1Es tu momento! Abre una sesi\u00f3n de R, dir\u00edgete hacia el directorio que desees, cre\u00e1ndolo o renombr\u00e1ndolo si fuese necesario, y comprueba su contenido antes de finalizar la sesi\u00f3n. Ejemplo 1 2 3 4 5 6 7 8 R getwd () dir.create ( \"tutorial\" ) list.dirs () file.rename ( \"tutorial\" , \"biotutorialR\" ) setwd ( \"biotutorialR\" ) list.files () q () Info Estas acciones pueden realizarse desde la terminal sin necesidad de llevarlas a cabo en una sesi\u00f3n de R. Los comandos ser\u00edan los siguientes: Comando Funci\u00f3n pwd Localizar el directorio donde se encuentra ls Visualizar su contenido cd ruta Cambiar de directorio mkdir nombre Crear un directorio rm -r nombre Borrar directorio y su contenido","title":"Iniciaci\u00f3n en el terminal y R"},{"location":"conceptos_basicos/#vocabulario-basico","text":"En programaci\u00f3n se emplea una jerga que a principiantes podr\u00eda resultar dificultoso su entendimiento. Un ejemplo que debe ser conocido antes de profundizar en la materia es el uso de los verbos llamar , correr y ejecutar , los cuales son referidos para que el lenguaje que se est\u00e9 utilizando realice una acci\u00f3n con la instrucci\u00f3n o entrada (\"input\") que se mencione. A partir de ella, se genera una salida (\"output\") que ser\u00eda el resultado de la operaci\u00f3n, para lo que se utiliza el verbo devolver . En ocasiones, un segmento de c\u00f3digo se repite, lo que se conoce como iteraci\u00f3n . Hay que tener en cuenta el s\u00edmbolo # , conocido como corchete o \"hashtag\", el cual suele introducirse en funciones para incluir comentarios del c\u00f3digo y que no sean ejecutados.","title":"Vocabulario b\u00e1sico"},{"location":"conceptos_basicos/#funciones-y-ayuda","text":"Las operaciones a ejecutar, junto a ciertas especificaciones denominadas argumento , se pueden asignar a un nombre, lo que se llama funci\u00f3n , la cual realiza las operaciones que contiene cuando se llama, por lo que se recomienda que su nombre represente o describa significativamente las operaciones, para que no surjan dudas de su acci\u00f3n. Las funciones se muestran de la siguiente forma: nombre_funci\u00f3n() . Existen ciertas funciones b\u00e1sicas que R reconoce desde un principio, como el c\u00e1lculo de la media, el cuantil y el tama\u00f1o o longitud de un objeto. Como se ha dicho, los nombres son descriptivos, por lo que las operaciones que lleva a cabo se deducen a simple vista, pero cuando se est\u00e1 indeciso sobre ellas, se puede recurrir a su documentaci\u00f3n, ya que todas las funciones tienen uno de estos archivos que describe lo que realiza la funci\u00f3n y detalles sobre sus argumentos, las operaciones y los resultados que devuelve, e incluye ejemplos de uso. La forma de acudir a este documento es situando el nombre dentro de la funci\u00f3n help() o escribiendo el operador interrogativo ? antes de su nombre. Si se utilizan en la terminal, para abandonar la documentaci\u00f3n se pulsa \u2191 + q . \u00bfQu\u00e9 operaciones realizar\u00edan las funciones mean() , quantile() , length() , summary() y sd() ? Respuesta Las tres primeras se han mencionado anteriormente como funciones b\u00e1sicas en el mismo orden que se preguntan, aunque si no se est\u00e1 seguro se puede recurrir a su documentaci\u00f3n. summary() y sd() podr\u00edan llevar a duda, por lo que se van a utilizar como ejemplo de acceso a documentaci\u00f3n. 1 2 help ( summary ) ? sd ()","title":"Funciones y ayuda"},{"location":"conceptos_basicos/#bibliotecas","text":"Las funciones pueden estar contenidas en paquetes , es decir, colecciones de funciones dise\u00f1adas para realizar tareas espec\u00edficas, como podr\u00eda ser alineamiento gen\u00f3mico o an\u00e1lisis de expresi\u00f3n gen\u00e9tica. Estos paquetes se encuentran disponibles en repositorios como bioconductor , el cual proporciona herramientas para el \u00e1mbito de la bioinform\u00e1tica e investigaci\u00f3n biom\u00e9dica. La forma de acceder a las funciones de estos paquetes es a trav\u00e9s de la funci\u00f3n library() , la cual se debe llamar cada vez que se inicie sesi\u00f3n en R. Para que reconozca el paquete de funciones, \u00e9ste deber\u00eda ser instalado previamente mediante la funci\u00f3n install.packages() . Otras funciones como installed.packages() y sessionInfo() permiten conocer qu\u00e9 paquetes est\u00e1n instalados en el sistema y cu\u00e1les est\u00e1n activos en la sesi\u00f3n abierta, respectivamente. Si se quiere actualizar un paquete ya instalado, se emplea la funci\u00f3n update.packages() . Todas estas funciones requieren indicar el paquete entre comillas. Comprueba si tienes instalados y actualizados las bibliotecas graphics y tidyverse . Si no fuese as\u00ed, intenta instalarlas, ya que ser\u00e1n utilizadas durante el tutorial. Accede al paquete stringr de tidyverse . M\u00e9todo 1 2 3 4 sessionInfo () update.packages ( \"graphics\" ) install.packages ( \"tidyverse\" ) library ( \"stringr\" )","title":"Bibliotecas"},{"location":"conceptos_basicos/#descarga-de-ficheros","text":"En una sesi\u00f3n de R se pueden descargar archivos mediante la funci\u00f3n download.file() , indicando en el argumento url la direcci\u00f3n de internet donde se encuentra el archivo que se pretende descargar, y en destfile el nombre con el que se quiera guardar el archivo en el ordenador, ambos entre comillas. Ejemplo 1 download.file ( url = \"https://www.ncbi.nlm.nih.gov/sviewer/viewer.cgi?tool=portal&save=file&log$=seqview&db=nuccore&report=fasta&id=973795115&extrafeat=null&conwithfeat=on&\" , destfile = \"prueba.fasta\" )","title":"Descarga de ficheros"},{"location":"conceptos_basicos/#scripts-en-r","text":"Un script es un archivo que inicialmente se puede crear con un editor de texto plano como gedit en Linux, o como notepad en Windows, y se guarda con la extensi\u00f3n .R . \u00c9ste puede ser ejecutado en R usando la funci\u00f3n source() , incluyendo la ruta del archivo entre comillas. Com\u00fanmente, el script incluye en su inicio la llamada a paquetes ( library() ) que el usuario podr\u00eda no tener instalados. Para que se muestre directamente alg\u00fan elemento del script, se debe incluir una funci\u00f3n de salida como print() , la cual devuelve el elemento que se introduzca en ella, o cat() , con la que se puede devolver un conjunto de elementos de forma secuencial. Adem\u00e1s, los scripts suelen utilizarse para operar con elementos que elige el usuario. El modo de pedir un \"input\" es incluyendo en el c\u00f3digo del script una funci\u00f3n de entrada como scan() , para n\u00fameros reales, o readline() , para caracteres, y asignarlos a una variable. Ejemplo 1 2 3 4 x <- readline ( prompt = \"Indique su nombre: \" ) print ( \"\u00bfQu\u00e9 edad tiene?\" ) y <- scan ( n = 1 ) cat ( x , \"tiene\" , y , \"a\u00f1os.\" ) Info La funci\u00f3n scan() permite indicar entre el par\u00e9ntesis el n\u00famero de entradas que podr\u00edas realizar. En caso de no hacerlo, podrias llevar a cabo las entradas que desees hasta que introduzcas una entrada vac\u00eda, finalizando el proceso de esta funci\u00f3n. La funci\u00f3n cat() no permite incluir ciertas estructuras de control como argumento, por ejemplo, las listas. \u00bfC\u00f3mo mostrar\u00edas el mensaje \"\u00a1Hola Mundo!\" por la pantalla? Respuesta 1 2 print ( \"\u00a1Hola Mundo!\" ) cat ( \"\u00a1Hola Mundo!\\n\" ) Enlaces de inter\u00e9s R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Scripts en R"},{"location":"data_frames/","text":"Los data frames son objetos recursivos que pueden reunir en su contenido los diferentes tipos de objetos b\u00e1sicos (num\u00e9rico, vector, etc). Su estructura bidimensional, ordenada por columnas (variables), filas (observaciones) y celdas (valores), facilita el almacenamiento de datos con los que se trabaja frecuentemente en cualquier \u00e1rea, puesto que se podr\u00eda entender como una tabla o una matriz. Si bien, el t\u00e9rmino anglicano data frame , es empleado en campos donde la v\u00eda de manipulaci\u00f3n de sus datos es la inform\u00e1tica y tiene una finalidad estad\u00edstica, como la bioinform\u00e1tica. De hecho, en el apartado Graficaci\u00f3n se requiere este tipo de objeto o aquellos que sean coercionables a data frame para la graficaci\u00f3n avanzada con ggplot2 . En primer lugar, ser\u00eda recomendable recordar los conocimientos b\u00e1sicos que tenemos de los data frames , los cuales se encuentran en Estructuras de datos . Para ello se muestra un simple ejemplo a continuaci\u00f3n: 1 2 3 4 5 6 7 8 9 10 11 12 a <- c ( 1 , 2 , 2 , 1 , 2 , 1 , 1 , 2 ) b <- c ( 5 , 6 , 3 , 1 , 4 , 2 , 7 , 8 ) df <- data.frame ( a , b ) #Creaci\u00f3n a partir de vectores c <- c ( \"A\" , \"C\" , \"B\" , \"F\" , \"E\" , \"G\" , \"H\" , \"D\" ) df <- cbind ( df , c ) #Nueva columna colnames ( df ) <- c ( \"Clase\" , \"Notas_medias\" , \"Profesor\" ) #Nombres de columnas a1 <- df [ 1 , 1 ] #Subconjuntos B <- df [, 2 ] c5 <- df [ 5 , \"Profesor\" ] C5 <- df $ Profesor [ 5 ] df $ Notas_medias [ 4 ] <- sqrt ( df $ Notas_medias [ 5 ]) #Operaciones df $ Profesor <- NULL #Elimina columna Funciones interesantes de R base \u00b6 Funci\u00f3n attach() \u00b6 Esta funci\u00f3n agiliza la manipulaci\u00f3n del data frame , ya que permite referenciar las columnas sin tener que especificar el nombre del data frame y la columna, esta \u00faltima precedida de $. La funci\u00f3n detach() desactiva a attach() . Ejemplo 1 2 3 attach ( df ) mean ( Notas_medias ) detach ( df ) Funci\u00f3n order() \u00b6 Esta funci\u00f3n permite ordenar predeterminadamente de forma creciente el contenido del data frame seleccionado. El argumento decreasing=T cambia el sentido de la ordenaci\u00f3n a decreciente. Ejemplo 1 df <- df [ order ( df $ Notas_medias , decreasing = T ),] Funci\u00f3n apply() \u00b6 Esta funci\u00f3n permite aplicar otras funciones al total del data frame num\u00e9rico. Esto es posible indicando en su interior el data frame deseado, si act\u00faa por fila o columna (n\u00fameros 1 y 2, respectivamente), y la funci\u00f3n a realizar. Esta funci\u00f3n se dirige a matrices o data frames de contenido num\u00e9rico, ya que produce NA en las celdas cuyo objeto at\u00f3mico es de otro tipo. Ejemplos 1 2 ejemplo_apply <- apply ( df , 2 , mean ) ejemplo_apply2 <- apply ( df , 2 , sum ) Funci\u00f3n by() \u00b6 Mediante by() se puede aplicar una funci\u00f3n determinada a un subgrupo del data frame . En primer lugar, se indica la columna a partir de la cual se pretende tomar las categor\u00edas que dividen el data frame . A continuaci\u00f3n, se indica la columna cuyos valores se someter\u00e1n a la funci\u00f3n, que se indica justo despu\u00e9s. El resultado es contenido en un tipo de objeto espec\u00edfico denominado by . Ejemplos 1 ejemplo_by <- by ( df $ Notas_medias , df $ Clase , summary ) Funci\u00f3n aggregate() \u00b6 Esta funci\u00f3n es muy similar a by() . La diferencia radica en sus argumentos y el resultado, ya que la columna debe ser presentada como una lista y el resultado es de tipo data frame . Ejemplos 1 ejemplo_aggregate <- aggregate ( df $ Notas_medias , list ( df $ Clase ), summary ) Funci\u00f3n split() \u00b6 El data frame puede ser dividido atendiendo a sus factores mediante esta funci\u00f3n. El resultado es contenido en una lista. Ejemplo 1 ejemplo_split <- split ( df , df $ Clase ) Funci\u00f3n subset() \u00b6 Ejemplo 1 ejemplo_subset <- subset ( df , Clase == 1 & Notas_medias >= 5 , select = Notas_medias ) Funci\u00f3n merge() \u00b6 Mediante merge() se pueden mezclar dos diferentes data frames que guarden relaci\u00f3n en alguna variable y sus observaciones. Ejemplo 1 2 3 df2 <- data.frame ( aa = c ( \"Val\" , \"Glu\" , \"Arg\" ), polaridad = c ( \"No polar\" , \"\u00c1cido\" , \"B\u00e1sico\" )) df3 <- data.frame ( aa = c ( \"Glu\" , \"Arg\" , \"Ile\" ), cantidad = c ( 23 , 10 , 14 )) ejemplo_merge <- merge ( df2 , df3 , by = \"aa\" ) Formatos de un data frame \u00b6 Los data frame pueden encontrarse en formato \"wide\" o \"long\" (ancho o largo), aunque existen modos parciales. El tipo de formato que presente el data frame es crucial en diferentes tipos de paquetes para tomar la informaci\u00f3n y tratarla. El conjunto de datos muestran formato ancho cuando diversos valores se encuentran en m\u00faltiples columnas. En cambio, el formato largo se refiere al data frame que contiene varias observaciones por variable. La diferencia es apreciable en los siguientes casos: 1 2 wide <- data.frame ( aa = c ( \"Glu\" , \"Cys\" ), enzima = c ( \"SOD\" , \"GSH\" ), p_hidr\u00f3geno = c ( 4 , 5 ), p_disulfuro = c ( 2 , 1 )) long <- data.frame ( aa = c ( \"Glu\" , \"Cys\" , \"Glu\" , \"Cys\" ), enzima = c ( \"SOD\" , \"GSH\" , \"SOD\" , \"GSH\" ), interaccion_puentes = c ( \"hidr\u00f3geno\" , \"disulfuro\" , \"disulfuro\" , \"hidr\u00f3geno\" ), cantidad = c ( 4 , 2 , 1 , 5 )) R base ofrece unas funciones para transformar el data frame de un formato a otro, lo que se conoce como pivotar: La funci\u00f3n stack() rehace el data frame de formato ancho a largo. La funci\u00f3n unstack() al contrario. Ejemplos 1 2 wide_a_long <- stack ( wide , select = c ( p_hidr\u00f3geno , p_disulfuro )) long_a_wide <- unstack ( long , cantidad ~ interaccion_puentes ) Existen otros paquetes que facilitan la manipulaci\u00f3n de formatos de un modo m\u00e1s avanzado. El m\u00e1s extendido es reshape2 , cuyas funciones melt() y dcast() llevan a cabo la transformaci\u00f3n a formato largo y ancho, respectivamente. Ejemplos 1 2 3 4 install.packages ( \"reshape2\" ) library ( reshape2 ) wide_a_long_reshape2 <- melt ( wide ) long_a_wide_reshape2 <- dcast ( long , aa ~ interaccion_puentes ) Si bien, tidyverse contiene el paquete tidyr , que permite realizar dichas transformaciones mediante las funciones gather() y spread() , que cambian el formato ancho y largo, de forma respectiva. Realmente, crean un nuevo objeto caracter\u00edstico de esta librer\u00eda, denominado tibble , el cual es similar a un data frame , al cual se le aportan ciertas caracter\u00edsticas. Ejemplos 1 2 3 library ( tidyr ) wide_a_long_tidyr <- gather ( wide , key = \"interaccion\" , value = \"cantidad\" , 3 : 4 ) long_a_wide_tidyr <- spread ( long , key = \"interaccion_puentes\" , value = \"cantidad\" , 3 : 4 ) El paquete tidyr va m\u00e1s all\u00e1 y ofrece diversas funciones de manipulaci\u00f3n de data frames , las cuales requieren de pipes para llamar al objeto al que se le aplicar\u00e1n. El pipe es una herramienta procedente del paquete magrittr de tidyverse que posibilita llevar a cabo m\u00faltiples operaciones consecutivas. Se indican con la siguiente combinaci\u00f3n de s\u00edmbolos: %>% . De hecho, gather() y spread() pueden ser sustituidos por las funciones pivot_longer() y pivot_wider() , respectivamente, si se utiliza el pipe para conectar con el objeto. Ejemplos 1 2 wide_a_long_pipe <- wide %>% pivot_longer ( 3 : 4 , names_to = \"interaccion\" , values_to = \"cantidad\" ) long_a_wide_pipe <- long %>% pivot_wider ( 1 : 4 , names_from = \"interaccion_puentes\" , values_from = \"cantidad\" ) Las funciones de tidyr separate() y unite() permiten separar o unir columnas, respectivamente, de acuerdo a la posici\u00f3n de un car\u00e1cter separador. Ejemplos 1 2 df <- df %>% unite ( clase_nota , Clase , Notas_medias ) df <- df_unite %>% separate ( clase_nota , into = c ( \"Clase\" , \"Notas_medias\" )) Tratamiento de datos con plyr y dplyr \u00b6 Estos paquetes pertenecen a la biblioteca tidyverse y facilitan el acceso y manipulaci\u00f3n de los datos de los data frames . En primer lugar, plyr es similar a la funci\u00f3n de R base apply() , ya que permite realizar una funci\u00f3n al conjunto de datos se\u00f1alado. Dependiendo del tipo de objeto que se quiera recibir como output de la funci\u00f3n, se aplicar\u00e1 un tipo de funci\u00f3n posible de plyr . Entre otras funciones destacan ddply() y dlply() , cuyas letras iniciales hacen referencia al objeto de entrada y de salida, respectivamente, siendo d por data frame y l a lista . Los argumentos b\u00e1sicos son el objeto de entrada, la variable y la funci\u00f3n deseada. Ejemplos 1 2 3 library ( plyr ) df_medias <- ddply ( .data = df , .variables = \"Clase\" , .fun = function ( x ) mean ( x $ Notas_medias )) df_list_max <- dlply ( .data = df , .variables = \"Clase\" , .fun = function ( x ) max ( x $ Notas_medias )) Por otro lado, dplyr ofrece diversas funciones que, en su gran mayor\u00eda, requieren de pipes. Una de ellas es filter() , la cual filtra el data frame por las columnas y observaciones deseadas. Adem\u00e1s, esta funci\u00f3n puede combinarse con otras mediante un nuevo pipe, como la funci\u00f3n select() , que agudiza la b\u00fasqueda de los datos deseados. Ejemplo 1 2 3 library ( dplyr ) df_clase1 <- df %>% filter ( Clase == \"1\" ) %>% select ( Notas_medias ) df_clase2 <- df %>% filter ( Clase == \"2\" ) %>% select ( Notas_medias ) Las funciones de dplyr mutate() y transmute() permiten a\u00f1adir nuevas variables (columnas) a partir de las ya existentes. Esta \u00faltima funci\u00f3n mantiene solamente la variable creada. Ejemplos 1 2 long_mutate <- long %>% mutate ( porcentaje = cantidad / 5 * 100 ) long_transmute <- long %>% transmute ( porcentaje = cantidad / 5 * 100 ) Ejercicio complementario \u00b6 Ejercicio resumen El archivo df_resumen.Rmd contiene dos ejercicios de manipulaci\u00f3n de data frame sobre los ficheros test1.xlsx , test2.xlsx y dominios.txt los cuales proceden de la realizaci\u00f3n de un proyecto durante el curso Aspectos F\u00edsico-Qu\u00edmicos de Interacciones en Biomol\u00e9culas. De este modo se pretende resumir de forma explicativa lo estudiado en este apartado, por lo que requiere la instalaci\u00f3n de las librer\u00edas tidyverse y reshape2 . Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . Nociones generales sobre R. M. Vargas , Universidad de Granada . R for Data Science. Garrett Grolemund & Hadley Wickham. R para profesionales de los datos: una introducci\u00f3n. Carlos J. Gil Bellosta . Ciencia de datos con R. Rub\u00e9n S\u00e1nchez Sancho .","title":"Manipulaci\u00f3n de data frames"},{"location":"data_frames/#funciones-interesantes-de-r-base","text":"","title":"Funciones interesantes de R base"},{"location":"data_frames/#funcion-attach","text":"Esta funci\u00f3n agiliza la manipulaci\u00f3n del data frame , ya que permite referenciar las columnas sin tener que especificar el nombre del data frame y la columna, esta \u00faltima precedida de $. La funci\u00f3n detach() desactiva a attach() . Ejemplo 1 2 3 attach ( df ) mean ( Notas_medias ) detach ( df )","title":"Funci\u00f3n attach()"},{"location":"data_frames/#funcion-order","text":"Esta funci\u00f3n permite ordenar predeterminadamente de forma creciente el contenido del data frame seleccionado. El argumento decreasing=T cambia el sentido de la ordenaci\u00f3n a decreciente. Ejemplo 1 df <- df [ order ( df $ Notas_medias , decreasing = T ),]","title":"Funci\u00f3n order()"},{"location":"data_frames/#funcion-apply","text":"Esta funci\u00f3n permite aplicar otras funciones al total del data frame num\u00e9rico. Esto es posible indicando en su interior el data frame deseado, si act\u00faa por fila o columna (n\u00fameros 1 y 2, respectivamente), y la funci\u00f3n a realizar. Esta funci\u00f3n se dirige a matrices o data frames de contenido num\u00e9rico, ya que produce NA en las celdas cuyo objeto at\u00f3mico es de otro tipo. Ejemplos 1 2 ejemplo_apply <- apply ( df , 2 , mean ) ejemplo_apply2 <- apply ( df , 2 , sum )","title":"Funci\u00f3n apply()"},{"location":"data_frames/#funcion-by","text":"Mediante by() se puede aplicar una funci\u00f3n determinada a un subgrupo del data frame . En primer lugar, se indica la columna a partir de la cual se pretende tomar las categor\u00edas que dividen el data frame . A continuaci\u00f3n, se indica la columna cuyos valores se someter\u00e1n a la funci\u00f3n, que se indica justo despu\u00e9s. El resultado es contenido en un tipo de objeto espec\u00edfico denominado by . Ejemplos 1 ejemplo_by <- by ( df $ Notas_medias , df $ Clase , summary )","title":"Funci\u00f3n by()"},{"location":"data_frames/#funcion-aggregate","text":"Esta funci\u00f3n es muy similar a by() . La diferencia radica en sus argumentos y el resultado, ya que la columna debe ser presentada como una lista y el resultado es de tipo data frame . Ejemplos 1 ejemplo_aggregate <- aggregate ( df $ Notas_medias , list ( df $ Clase ), summary )","title":"Funci\u00f3n aggregate()"},{"location":"data_frames/#funcion-split","text":"El data frame puede ser dividido atendiendo a sus factores mediante esta funci\u00f3n. El resultado es contenido en una lista. Ejemplo 1 ejemplo_split <- split ( df , df $ Clase )","title":"Funci\u00f3n split()"},{"location":"data_frames/#funcion-subset","text":"Ejemplo 1 ejemplo_subset <- subset ( df , Clase == 1 & Notas_medias >= 5 , select = Notas_medias )","title":"Funci\u00f3n subset()"},{"location":"data_frames/#funcion-merge","text":"Mediante merge() se pueden mezclar dos diferentes data frames que guarden relaci\u00f3n en alguna variable y sus observaciones. Ejemplo 1 2 3 df2 <- data.frame ( aa = c ( \"Val\" , \"Glu\" , \"Arg\" ), polaridad = c ( \"No polar\" , \"\u00c1cido\" , \"B\u00e1sico\" )) df3 <- data.frame ( aa = c ( \"Glu\" , \"Arg\" , \"Ile\" ), cantidad = c ( 23 , 10 , 14 )) ejemplo_merge <- merge ( df2 , df3 , by = \"aa\" )","title":"Funci\u00f3n merge()"},{"location":"data_frames/#formatos-de-un-data-frame","text":"Los data frame pueden encontrarse en formato \"wide\" o \"long\" (ancho o largo), aunque existen modos parciales. El tipo de formato que presente el data frame es crucial en diferentes tipos de paquetes para tomar la informaci\u00f3n y tratarla. El conjunto de datos muestran formato ancho cuando diversos valores se encuentran en m\u00faltiples columnas. En cambio, el formato largo se refiere al data frame que contiene varias observaciones por variable. La diferencia es apreciable en los siguientes casos: 1 2 wide <- data.frame ( aa = c ( \"Glu\" , \"Cys\" ), enzima = c ( \"SOD\" , \"GSH\" ), p_hidr\u00f3geno = c ( 4 , 5 ), p_disulfuro = c ( 2 , 1 )) long <- data.frame ( aa = c ( \"Glu\" , \"Cys\" , \"Glu\" , \"Cys\" ), enzima = c ( \"SOD\" , \"GSH\" , \"SOD\" , \"GSH\" ), interaccion_puentes = c ( \"hidr\u00f3geno\" , \"disulfuro\" , \"disulfuro\" , \"hidr\u00f3geno\" ), cantidad = c ( 4 , 2 , 1 , 5 )) R base ofrece unas funciones para transformar el data frame de un formato a otro, lo que se conoce como pivotar: La funci\u00f3n stack() rehace el data frame de formato ancho a largo. La funci\u00f3n unstack() al contrario. Ejemplos 1 2 wide_a_long <- stack ( wide , select = c ( p_hidr\u00f3geno , p_disulfuro )) long_a_wide <- unstack ( long , cantidad ~ interaccion_puentes ) Existen otros paquetes que facilitan la manipulaci\u00f3n de formatos de un modo m\u00e1s avanzado. El m\u00e1s extendido es reshape2 , cuyas funciones melt() y dcast() llevan a cabo la transformaci\u00f3n a formato largo y ancho, respectivamente. Ejemplos 1 2 3 4 install.packages ( \"reshape2\" ) library ( reshape2 ) wide_a_long_reshape2 <- melt ( wide ) long_a_wide_reshape2 <- dcast ( long , aa ~ interaccion_puentes ) Si bien, tidyverse contiene el paquete tidyr , que permite realizar dichas transformaciones mediante las funciones gather() y spread() , que cambian el formato ancho y largo, de forma respectiva. Realmente, crean un nuevo objeto caracter\u00edstico de esta librer\u00eda, denominado tibble , el cual es similar a un data frame , al cual se le aportan ciertas caracter\u00edsticas. Ejemplos 1 2 3 library ( tidyr ) wide_a_long_tidyr <- gather ( wide , key = \"interaccion\" , value = \"cantidad\" , 3 : 4 ) long_a_wide_tidyr <- spread ( long , key = \"interaccion_puentes\" , value = \"cantidad\" , 3 : 4 ) El paquete tidyr va m\u00e1s all\u00e1 y ofrece diversas funciones de manipulaci\u00f3n de data frames , las cuales requieren de pipes para llamar al objeto al que se le aplicar\u00e1n. El pipe es una herramienta procedente del paquete magrittr de tidyverse que posibilita llevar a cabo m\u00faltiples operaciones consecutivas. Se indican con la siguiente combinaci\u00f3n de s\u00edmbolos: %>% . De hecho, gather() y spread() pueden ser sustituidos por las funciones pivot_longer() y pivot_wider() , respectivamente, si se utiliza el pipe para conectar con el objeto. Ejemplos 1 2 wide_a_long_pipe <- wide %>% pivot_longer ( 3 : 4 , names_to = \"interaccion\" , values_to = \"cantidad\" ) long_a_wide_pipe <- long %>% pivot_wider ( 1 : 4 , names_from = \"interaccion_puentes\" , values_from = \"cantidad\" ) Las funciones de tidyr separate() y unite() permiten separar o unir columnas, respectivamente, de acuerdo a la posici\u00f3n de un car\u00e1cter separador. Ejemplos 1 2 df <- df %>% unite ( clase_nota , Clase , Notas_medias ) df <- df_unite %>% separate ( clase_nota , into = c ( \"Clase\" , \"Notas_medias\" ))","title":"Formatos de un data frame"},{"location":"data_frames/#tratamiento-de-datos-con-plyr-y-dplyr","text":"Estos paquetes pertenecen a la biblioteca tidyverse y facilitan el acceso y manipulaci\u00f3n de los datos de los data frames . En primer lugar, plyr es similar a la funci\u00f3n de R base apply() , ya que permite realizar una funci\u00f3n al conjunto de datos se\u00f1alado. Dependiendo del tipo de objeto que se quiera recibir como output de la funci\u00f3n, se aplicar\u00e1 un tipo de funci\u00f3n posible de plyr . Entre otras funciones destacan ddply() y dlply() , cuyas letras iniciales hacen referencia al objeto de entrada y de salida, respectivamente, siendo d por data frame y l a lista . Los argumentos b\u00e1sicos son el objeto de entrada, la variable y la funci\u00f3n deseada. Ejemplos 1 2 3 library ( plyr ) df_medias <- ddply ( .data = df , .variables = \"Clase\" , .fun = function ( x ) mean ( x $ Notas_medias )) df_list_max <- dlply ( .data = df , .variables = \"Clase\" , .fun = function ( x ) max ( x $ Notas_medias )) Por otro lado, dplyr ofrece diversas funciones que, en su gran mayor\u00eda, requieren de pipes. Una de ellas es filter() , la cual filtra el data frame por las columnas y observaciones deseadas. Adem\u00e1s, esta funci\u00f3n puede combinarse con otras mediante un nuevo pipe, como la funci\u00f3n select() , que agudiza la b\u00fasqueda de los datos deseados. Ejemplo 1 2 3 library ( dplyr ) df_clase1 <- df %>% filter ( Clase == \"1\" ) %>% select ( Notas_medias ) df_clase2 <- df %>% filter ( Clase == \"2\" ) %>% select ( Notas_medias ) Las funciones de dplyr mutate() y transmute() permiten a\u00f1adir nuevas variables (columnas) a partir de las ya existentes. Esta \u00faltima funci\u00f3n mantiene solamente la variable creada. Ejemplos 1 2 long_mutate <- long %>% mutate ( porcentaje = cantidad / 5 * 100 ) long_transmute <- long %>% transmute ( porcentaje = cantidad / 5 * 100 )","title":"Tratamiento de datos con plyr y dplyr"},{"location":"data_frames/#ejercicio-complementario","text":"Ejercicio resumen El archivo df_resumen.Rmd contiene dos ejercicios de manipulaci\u00f3n de data frame sobre los ficheros test1.xlsx , test2.xlsx y dominios.txt los cuales proceden de la realizaci\u00f3n de un proyecto durante el curso Aspectos F\u00edsico-Qu\u00edmicos de Interacciones en Biomol\u00e9culas. De este modo se pretende resumir de forma explicativa lo estudiado en este apartado, por lo que requiere la instalaci\u00f3n de las librer\u00edas tidyverse y reshape2 . Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . Nociones generales sobre R. M. Vargas , Universidad de Granada . R for Data Science. Garrett Grolemund & Hadley Wickham. R para profesionales de los datos: una introducci\u00f3n. Carlos J. Gil Bellosta . Ciencia de datos con R. Rub\u00e9n S\u00e1nchez Sancho .","title":"Ejercicio complementario"},{"location":"estructuras_control/","text":"Las estructuras de control son construcciones sint\u00e1cticas que determinan la l\u00f3gica y el orden de c\u00f3mo ocurren las operaciones de nuestro programa, es decir, dirijen el flujo de \u00e9stas y controlan la ejecuci\u00f3n del c\u00f3digo en una direcci\u00f3n u otra. Para ello, es fundamental establecer condicionales en el c\u00f3digo. Construcciones if - else \u00b6 Esta sintaxis inglesa realiza la funci\u00f3n de lo que literalmente se traduce de ella. Esto es, \"si\" y \"de otro modo\", para if y else , respectivamente. De una forma m\u00e1s concreta, se entiende como \" si esta condici\u00f3n es TRUE , ejecuta la siguiente operaci\u00f3n, de otro modo ejecuta \u00e9sta otra \". La construcci\u00f3n dentro del programa se incluir\u00eda as\u00ed: 1 2 3 4 5 if ( condici\u00f3n ) { operaciones_si_condici\u00f3n = TRUE } else { operaciones_si_condici\u00f3n = FALSE } No obstante, la construcci\u00f3n puede incluir \u00fanicamente if , para indicar que se ejecute una operaci\u00f3n si se cumple la condici\u00f3n, sino se contin\u00faa con el programa. 1 2 3 if ( condici\u00f3n ) { operaciones_si_condici\u00f3n = TRUE } Ejemplo 1 2 3 4 euros <- -20 if ( euros < 0 ){ print ( \"Est\u00e1s en n\u00fameros negativos\" ) } Si bien, es cierto que podr\u00eda escribirse del siguiente modo: 1 2 if ( condici\u00f3n ) { operaciones_si_condici\u00f3n = TRUE } else { operaciones_si_condici\u00f3n = FALSE } Las operaciones se deben incluir solamente en una expresi\u00f3n, por lo que si hay m\u00e1s de una operaci\u00f3n se conectan mediante el operador ; o pasando al siguiente rengl\u00f3n y manteniendo la iteraci\u00f3n. 1 2 3 4 5 6 if ( condici\u00f3n ) { operaci\u00f3n1_si_condici\u00f3n = TRUE operaci\u00f3n2 } else { operaciones_si_condici\u00f3n = FALSE } Por otro lado, la contrucci\u00f3n podr\u00eda componerse de m\u00faltiples condiciones. Para ello, junto a else se sit\u00faa de nuevo if . 1 2 3 4 5 6 7 if ( condici\u00f3n1 ) { operaciones_si_condici\u00f3n = TRUE } else if ( condici\u00f3n2 ) { operaciones_si_condici\u00f3n1 = FALSE_condici\u00f3n2 = TRUE } else { operaciones_si_condiciones = FALSE } Ejemplo 1 2 3 4 5 6 7 8 9 num_real <- 5.43 num_entero <- -10 if ( num_real < num_entero ) { \"condici\u00f3n1-TRUE\" } else if ( num_real > num_entero & num_entero > num_integer ) { \"condici\u00f3n2-TRUE\" } else { \"condiciones-FALSE\" } Hasta ahora, las construcciones mencionadas no permiten incluir secuencias o vectores. Si bien, la funci\u00f3n ifelse() se emplea para controlar el flujo en esta estructura de datos, lo que tambi\u00e9n incluye valores independientes, sin necesidad de conformar una secuencia. Esta funci\u00f3n nos devuelve un vector con los valores correspondientes para cada elemento del vector tras realizar su respectiva operaci\u00f3n, atendiendo a las condiciones interpuestas. Ejemplo 1 ifelse1 <- ifelse ( c ( 3 , 4 , 5 , 6 , 7 ) < num_real , \"condici\u00f3n-TRUE\" , \"condici\u00f3n-FALSE\" ) Cree un script llamado sup_inf_igual_0.R que indique si el n\u00famero introducido es superior, inferior, o igual a 0. Respuesta 1 2 3 4 5 6 7 8 9 print ( \"N\u00famero que desea conocer c\u00f3mo es respecto a 0: \" ) num <- scan ( n = 1 ) if ( num == 0 ) { cat ( num , \"es igual a 0.\" ) } else if ( num < 0 ) { cat ( num , \"es menor que 0.\" ) } else { cat ( num , \"es mayor que 0.\" ) } Bucles for \u00b6 Este tipo de construcciones repite las operaciones que contiene un n\u00famero determinado de veces, las cuales se indican entre par\u00e9ntesis y corresponden al n\u00famero de veces que se observa un elemento en la estructura de datos que introduzcamos. Las operaciones se pueden llevar a cabo con el elemento en cuesti\u00f3n, al cual se le puede nombrar como guste, siendo com\u00fan la letra i o una palabra descritiva. En cuanto a la estructura de datos, debe de ser un objeto ya existente o que se formule en la construcci\u00f3n, cuyo modelo es el siguiente: 1 2 3 for ( elemento in estructura ){ operaciones_con / sin_elemento } Ejemplos 1 2 3 4 5 6 7 for ( i in 1 : 10 ){ print ( i ) } lista1 <- list ( equipo = \"verde\" , componentes = 2 , nombres = c ( \"Ana\" , \"Juan\" ), ganador = TRUE ) for ( i in lista1 ) { i } Info Los bucles no devuelven los resultados a no ser que se lo indiques expl\u00edcitamente con funciones como print() . Adem\u00e1s, si se pretende asignar los resultados a una variable, \u00e9sta debe de haber sido declarada previamente, y se utiliza el operador [] , de forma que la estructura de datos contenida en la variable aumentar\u00eda su longitud por cada repetici\u00f3n. 1 2 3 4 vector_for1 <- 1 for ( i in 2 : 7 ) { vector_for1 [ i ] <- i } Hay que tener cuidado con las estructuras que empleamos en el bucle y los datos que contienen, ya que podr\u00edan devolver errores o resultados no esperados cuando se mezclan tipos de datos en ellas. Esto y la simplicidad y velocidad de c\u00f3mputo que ofrecen otras opciones de R, hacen que este bucle no sea tan utilizado. 1 2 3 4 vector_for2 <- NULL for ( i in list ( 1 : 4 , 6 , 8 , \"c\" , \"a\" )) { vector_for2 [ i ] <- i } Cree un script fibonacci.R que devuelva la sucesi\u00f3n de Fibonacci del n\u00famero indicado. Respuesta 1 2 3 4 5 6 7 8 9 10 print ( \"Introduzca un n\u00famero: \" ) n <- scan ( n = 1 ) a <- 0 b <- 1 cat ( \"Los\" , n , \"primeros n\u00fameros de la sucesi\u00f3n de Fibonacci son:\" , \"\\n\" ) for ( i in 1 : n ) { a <- a + b b <- a - b cat ( \"El n\u00famero de la posici\u00f3n\" , i , \"es\" , a , \"\\n\" ) } Bucles while \u00b6 Este tipo de bucle repite las operaciones mientras la condici\u00f3n impuesta sea TRUE . El modelo para lograr esta contrucci\u00f3n es el siguiente: 1 2 3 while ( condicion ) { operaciones_si_condicion = TRUE } Si realiz\u00e1semos el modelo tal cual se ha mostrado y la condici\u00f3n sea siempre TRUE , se producir\u00eda un bucle infinito , el cual se abandona presionando la tecla ESC si est\u00e1s en RStudio, o ctrl + c para la terminal, ya que se podr\u00eda congelar el ordenador. Por ello, es necesario operar con los objetos que formen parte de la condici\u00f3n, de forma que en un momento la condici\u00f3n sea FALSE y pare el bucle. Ejemplo 1 2 3 while ( num_real > 1 | num_entero < num_real ) { num_real <- num_real - 3 } Cree un script llamado suma_enteros_100.R que realice la suma de los n\u00fameros enteros comprendidos entre el n\u00famero indicado y 100. Respuesta 1 2 3 4 5 6 7 8 print ( \"Indique un n\u00famero entre 0 y 100: \" ) suma <- 0 n <- scan ( n = 1 ) while ( n <= 100 ){ suma <- suma + n n <- n +1 } cat ( \"El valor de la suma de enteros hasta 100 es\" , suma ) Break , Next y bucles repeat \u00b6 Las estructuras de control break y next son palabras reservadas que no pueden emplearse como variable. Ambas se utilizan dentro de otras estructuras de control y requieren que una condici\u00f3n sea TRUE para que se efect\u00fae su acci\u00f3n, que para break es finalizar el bucle, mientras que next avanza a la siguiente iteraci\u00f3n sin realizar operaci\u00f3n. De hecho, break es necesario para no caer en un bucle infinito creado con la estructura repeat , la cual no se usa con frecuencia. Si bien, el modelo de este bucle es el siguiente: 1 2 3 4 repeat { operaciones break } Ejemplos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 repeat { num_real <- num_real / 2 if ( num_real > -4 ) { break } } vector11 <- c () for ( i in vector_for1 ) { if ( i == 6 ) { next } vector11 [ i ] <- vector_for1 [ i ] * 2 } while ( num_entero != 6 ) { if ( num_entero == 5 ) { break } num_entero <- num_entero + 5 } Modifique el script suma_enteros_100.R de forma que ignore el valor 50 y finalice el programa si la suma supera el valor 2000. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 print ( \"Indique un n\u00famero entre 0 y 100: \" ) suma <- 0 n <- scan ( n = 1 ) for ( i in n : 100 ){ if ( i == 50 ){ next } if ( suma > 2000 ){ break } suma <- suma + i } cat ( \"El valor de la suma de enteros hasta que supera por primera vez el valor 2000 es\" , suma ) Declaraciones switch \u00b6 Este tipo de construcci\u00f3n permite al usuario elegir la operaci\u00f3n que se llevar\u00eda a cabo al ejecutar el c\u00f3digo. Para ello, se debe incluir una funci\u00f3n de entrada como readline() tras una de salida que muestre informaci\u00f3n sobre las opciones. Por lo tanto, presentar\u00eda la forma siguiente: 1 2 3 4 5 6 7 print ( \"Opciones: a, b y c) eleccion <- readline(prompt=\" Elija una de las anteriores opciones : \") switch(eleccion, a=operaci\u00f3n_a, b=operaci\u00f3n_b, c=operaci\u00f3n_c, stop(\" Opci\u00f3n no v\u00e1lida \" )) Ejemplo 1 2 3 4 5 6 print ( \"La operaci\u00f3n log(20) + 4*7 >= 2^5 | length(c(1:6)) <= log10(6^8) es TRUE.\" ) respuesta <- readline ( prompt = \"\u00bfEs cierta la afirmaci\u00f3n anterior? (a=Verdadero, b=Falso): \" ) switch ( respuesta , a = print ( \"Correcto\" ), b = print ( \"Incorrecto\" ), stop ( \"Opci\u00f3n no v\u00e1lida\" )) Cree un script llamado elegir_script.R que te ofrezca la oportunidad de elegir ejecutar el script fibonacci, o suma_enteros_100.R Respuesta 1 2 3 4 5 6 7 8 9 10 print ( \"Opciones:\" ) print ( \"A. sup_inf_igual_0.R\" ) print ( \"B. suma_enteros_100.R\" ) print ( \"C. fibonacci.R\" ) eleccion <- readline ( prompt = \"Elija el script que desee ejecutar: \" ) switch ( eleccion , A = source ( \"sup_inf_igual_0.R\" ), B = source ( \"fibonacci.R\" ), C = source ( \"suma_enteros_100.R\" , stop ( \"Opci\u00f3n no v\u00e1lida\" )) Ejercicios complementarios \u00b6 Cree un script llamado tabla_mult_completo.R que devuelva la tabla de multiplicar del n\u00famero deseado. Respuesta 1 2 3 4 5 print ( \"\u00bfDe qu\u00e9 n\u00famero desea conocer su tabla de multiplicar? \" ) num <- scan ( n = 1 ) for ( i in 0 : 10 ){ cat ( num , \"*\" , i , \"=\" , i * num , \"\\n\" ) } Cree, recurriendo a nota_media.R, un script llamado sobresalientes.R que devuelva una lista con los alumnos de clase cuya media es de sobresaliente. Respuesta 1 2 3 4 5 6 7 8 9 10 11 print ( \"N\u00famero de alumnos en clase:\" ) num_alumnos <- scan ( n = 1 ) sobresalientes <- c () for ( i in 1 : num_alumnos ){ source ( \"nota_media.R\" ) if ( lista $ nota_media >= 9 ) { sobresalientes [ i ] <- lista $ nombre } } lista_sb <- list ( alumnos_sobresalientes = sobresalientes ) print ( lista_sb ) Cree un script llamado juego_adivinar_num.R que permita jugar a adivinar un n\u00famero aleatorio del 1 al 10. \u00bfSer\u00edas capaz de crear un cuaderno de R donde expliques el programa? Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 secreto <- sample ( 1 : 10 , 1 ) found <- TRUE while ( found ){ print ( \"Prueba un n\u00famero: \" ) n <- scan ( n = 1 ) if ( n < secreto ) { print ( \"El numero que has pensado es mayor\" ) } else { print ( \"El numero que has pensado es menor\" ) } if ( n == secreto ){ print ( \"\u00a1ACERTASTE!\" ) break } } Consulta en el siguiente fichero si tu cuaderno es correcto: juego_adivinar.Rmd Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Estructuras de control"},{"location":"estructuras_control/#construcciones-if-else","text":"Esta sintaxis inglesa realiza la funci\u00f3n de lo que literalmente se traduce de ella. Esto es, \"si\" y \"de otro modo\", para if y else , respectivamente. De una forma m\u00e1s concreta, se entiende como \" si esta condici\u00f3n es TRUE , ejecuta la siguiente operaci\u00f3n, de otro modo ejecuta \u00e9sta otra \". La construcci\u00f3n dentro del programa se incluir\u00eda as\u00ed: 1 2 3 4 5 if ( condici\u00f3n ) { operaciones_si_condici\u00f3n = TRUE } else { operaciones_si_condici\u00f3n = FALSE } No obstante, la construcci\u00f3n puede incluir \u00fanicamente if , para indicar que se ejecute una operaci\u00f3n si se cumple la condici\u00f3n, sino se contin\u00faa con el programa. 1 2 3 if ( condici\u00f3n ) { operaciones_si_condici\u00f3n = TRUE } Ejemplo 1 2 3 4 euros <- -20 if ( euros < 0 ){ print ( \"Est\u00e1s en n\u00fameros negativos\" ) } Si bien, es cierto que podr\u00eda escribirse del siguiente modo: 1 2 if ( condici\u00f3n ) { operaciones_si_condici\u00f3n = TRUE } else { operaciones_si_condici\u00f3n = FALSE } Las operaciones se deben incluir solamente en una expresi\u00f3n, por lo que si hay m\u00e1s de una operaci\u00f3n se conectan mediante el operador ; o pasando al siguiente rengl\u00f3n y manteniendo la iteraci\u00f3n. 1 2 3 4 5 6 if ( condici\u00f3n ) { operaci\u00f3n1_si_condici\u00f3n = TRUE operaci\u00f3n2 } else { operaciones_si_condici\u00f3n = FALSE } Por otro lado, la contrucci\u00f3n podr\u00eda componerse de m\u00faltiples condiciones. Para ello, junto a else se sit\u00faa de nuevo if . 1 2 3 4 5 6 7 if ( condici\u00f3n1 ) { operaciones_si_condici\u00f3n = TRUE } else if ( condici\u00f3n2 ) { operaciones_si_condici\u00f3n1 = FALSE_condici\u00f3n2 = TRUE } else { operaciones_si_condiciones = FALSE } Ejemplo 1 2 3 4 5 6 7 8 9 num_real <- 5.43 num_entero <- -10 if ( num_real < num_entero ) { \"condici\u00f3n1-TRUE\" } else if ( num_real > num_entero & num_entero > num_integer ) { \"condici\u00f3n2-TRUE\" } else { \"condiciones-FALSE\" } Hasta ahora, las construcciones mencionadas no permiten incluir secuencias o vectores. Si bien, la funci\u00f3n ifelse() se emplea para controlar el flujo en esta estructura de datos, lo que tambi\u00e9n incluye valores independientes, sin necesidad de conformar una secuencia. Esta funci\u00f3n nos devuelve un vector con los valores correspondientes para cada elemento del vector tras realizar su respectiva operaci\u00f3n, atendiendo a las condiciones interpuestas. Ejemplo 1 ifelse1 <- ifelse ( c ( 3 , 4 , 5 , 6 , 7 ) < num_real , \"condici\u00f3n-TRUE\" , \"condici\u00f3n-FALSE\" ) Cree un script llamado sup_inf_igual_0.R que indique si el n\u00famero introducido es superior, inferior, o igual a 0. Respuesta 1 2 3 4 5 6 7 8 9 print ( \"N\u00famero que desea conocer c\u00f3mo es respecto a 0: \" ) num <- scan ( n = 1 ) if ( num == 0 ) { cat ( num , \"es igual a 0.\" ) } else if ( num < 0 ) { cat ( num , \"es menor que 0.\" ) } else { cat ( num , \"es mayor que 0.\" ) }","title":"Construcciones if - else"},{"location":"estructuras_control/#bucles-for","text":"Este tipo de construcciones repite las operaciones que contiene un n\u00famero determinado de veces, las cuales se indican entre par\u00e9ntesis y corresponden al n\u00famero de veces que se observa un elemento en la estructura de datos que introduzcamos. Las operaciones se pueden llevar a cabo con el elemento en cuesti\u00f3n, al cual se le puede nombrar como guste, siendo com\u00fan la letra i o una palabra descritiva. En cuanto a la estructura de datos, debe de ser un objeto ya existente o que se formule en la construcci\u00f3n, cuyo modelo es el siguiente: 1 2 3 for ( elemento in estructura ){ operaciones_con / sin_elemento } Ejemplos 1 2 3 4 5 6 7 for ( i in 1 : 10 ){ print ( i ) } lista1 <- list ( equipo = \"verde\" , componentes = 2 , nombres = c ( \"Ana\" , \"Juan\" ), ganador = TRUE ) for ( i in lista1 ) { i } Info Los bucles no devuelven los resultados a no ser que se lo indiques expl\u00edcitamente con funciones como print() . Adem\u00e1s, si se pretende asignar los resultados a una variable, \u00e9sta debe de haber sido declarada previamente, y se utiliza el operador [] , de forma que la estructura de datos contenida en la variable aumentar\u00eda su longitud por cada repetici\u00f3n. 1 2 3 4 vector_for1 <- 1 for ( i in 2 : 7 ) { vector_for1 [ i ] <- i } Hay que tener cuidado con las estructuras que empleamos en el bucle y los datos que contienen, ya que podr\u00edan devolver errores o resultados no esperados cuando se mezclan tipos de datos en ellas. Esto y la simplicidad y velocidad de c\u00f3mputo que ofrecen otras opciones de R, hacen que este bucle no sea tan utilizado. 1 2 3 4 vector_for2 <- NULL for ( i in list ( 1 : 4 , 6 , 8 , \"c\" , \"a\" )) { vector_for2 [ i ] <- i } Cree un script fibonacci.R que devuelva la sucesi\u00f3n de Fibonacci del n\u00famero indicado. Respuesta 1 2 3 4 5 6 7 8 9 10 print ( \"Introduzca un n\u00famero: \" ) n <- scan ( n = 1 ) a <- 0 b <- 1 cat ( \"Los\" , n , \"primeros n\u00fameros de la sucesi\u00f3n de Fibonacci son:\" , \"\\n\" ) for ( i in 1 : n ) { a <- a + b b <- a - b cat ( \"El n\u00famero de la posici\u00f3n\" , i , \"es\" , a , \"\\n\" ) }","title":"Bucles for"},{"location":"estructuras_control/#bucles-while","text":"Este tipo de bucle repite las operaciones mientras la condici\u00f3n impuesta sea TRUE . El modelo para lograr esta contrucci\u00f3n es el siguiente: 1 2 3 while ( condicion ) { operaciones_si_condicion = TRUE } Si realiz\u00e1semos el modelo tal cual se ha mostrado y la condici\u00f3n sea siempre TRUE , se producir\u00eda un bucle infinito , el cual se abandona presionando la tecla ESC si est\u00e1s en RStudio, o ctrl + c para la terminal, ya que se podr\u00eda congelar el ordenador. Por ello, es necesario operar con los objetos que formen parte de la condici\u00f3n, de forma que en un momento la condici\u00f3n sea FALSE y pare el bucle. Ejemplo 1 2 3 while ( num_real > 1 | num_entero < num_real ) { num_real <- num_real - 3 } Cree un script llamado suma_enteros_100.R que realice la suma de los n\u00fameros enteros comprendidos entre el n\u00famero indicado y 100. Respuesta 1 2 3 4 5 6 7 8 print ( \"Indique un n\u00famero entre 0 y 100: \" ) suma <- 0 n <- scan ( n = 1 ) while ( n <= 100 ){ suma <- suma + n n <- n +1 } cat ( \"El valor de la suma de enteros hasta 100 es\" , suma )","title":"Bucles while"},{"location":"estructuras_control/#break-next-y-bucles-repeat","text":"Las estructuras de control break y next son palabras reservadas que no pueden emplearse como variable. Ambas se utilizan dentro de otras estructuras de control y requieren que una condici\u00f3n sea TRUE para que se efect\u00fae su acci\u00f3n, que para break es finalizar el bucle, mientras que next avanza a la siguiente iteraci\u00f3n sin realizar operaci\u00f3n. De hecho, break es necesario para no caer en un bucle infinito creado con la estructura repeat , la cual no se usa con frecuencia. Si bien, el modelo de este bucle es el siguiente: 1 2 3 4 repeat { operaciones break } Ejemplos 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 repeat { num_real <- num_real / 2 if ( num_real > -4 ) { break } } vector11 <- c () for ( i in vector_for1 ) { if ( i == 6 ) { next } vector11 [ i ] <- vector_for1 [ i ] * 2 } while ( num_entero != 6 ) { if ( num_entero == 5 ) { break } num_entero <- num_entero + 5 } Modifique el script suma_enteros_100.R de forma que ignore el valor 50 y finalice el programa si la suma supera el valor 2000. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 print ( \"Indique un n\u00famero entre 0 y 100: \" ) suma <- 0 n <- scan ( n = 1 ) for ( i in n : 100 ){ if ( i == 50 ){ next } if ( suma > 2000 ){ break } suma <- suma + i } cat ( \"El valor de la suma de enteros hasta que supera por primera vez el valor 2000 es\" , suma )","title":"Break, Next y bucles repeat"},{"location":"estructuras_control/#declaraciones-switch","text":"Este tipo de construcci\u00f3n permite al usuario elegir la operaci\u00f3n que se llevar\u00eda a cabo al ejecutar el c\u00f3digo. Para ello, se debe incluir una funci\u00f3n de entrada como readline() tras una de salida que muestre informaci\u00f3n sobre las opciones. Por lo tanto, presentar\u00eda la forma siguiente: 1 2 3 4 5 6 7 print ( \"Opciones: a, b y c) eleccion <- readline(prompt=\" Elija una de las anteriores opciones : \") switch(eleccion, a=operaci\u00f3n_a, b=operaci\u00f3n_b, c=operaci\u00f3n_c, stop(\" Opci\u00f3n no v\u00e1lida \" )) Ejemplo 1 2 3 4 5 6 print ( \"La operaci\u00f3n log(20) + 4*7 >= 2^5 | length(c(1:6)) <= log10(6^8) es TRUE.\" ) respuesta <- readline ( prompt = \"\u00bfEs cierta la afirmaci\u00f3n anterior? (a=Verdadero, b=Falso): \" ) switch ( respuesta , a = print ( \"Correcto\" ), b = print ( \"Incorrecto\" ), stop ( \"Opci\u00f3n no v\u00e1lida\" )) Cree un script llamado elegir_script.R que te ofrezca la oportunidad de elegir ejecutar el script fibonacci, o suma_enteros_100.R Respuesta 1 2 3 4 5 6 7 8 9 10 print ( \"Opciones:\" ) print ( \"A. sup_inf_igual_0.R\" ) print ( \"B. suma_enteros_100.R\" ) print ( \"C. fibonacci.R\" ) eleccion <- readline ( prompt = \"Elija el script que desee ejecutar: \" ) switch ( eleccion , A = source ( \"sup_inf_igual_0.R\" ), B = source ( \"fibonacci.R\" ), C = source ( \"suma_enteros_100.R\" , stop ( \"Opci\u00f3n no v\u00e1lida\" ))","title":"Declaraciones switch"},{"location":"estructuras_control/#ejercicios-complementarios","text":"Cree un script llamado tabla_mult_completo.R que devuelva la tabla de multiplicar del n\u00famero deseado. Respuesta 1 2 3 4 5 print ( \"\u00bfDe qu\u00e9 n\u00famero desea conocer su tabla de multiplicar? \" ) num <- scan ( n = 1 ) for ( i in 0 : 10 ){ cat ( num , \"*\" , i , \"=\" , i * num , \"\\n\" ) } Cree, recurriendo a nota_media.R, un script llamado sobresalientes.R que devuelva una lista con los alumnos de clase cuya media es de sobresaliente. Respuesta 1 2 3 4 5 6 7 8 9 10 11 print ( \"N\u00famero de alumnos en clase:\" ) num_alumnos <- scan ( n = 1 ) sobresalientes <- c () for ( i in 1 : num_alumnos ){ source ( \"nota_media.R\" ) if ( lista $ nota_media >= 9 ) { sobresalientes [ i ] <- lista $ nombre } } lista_sb <- list ( alumnos_sobresalientes = sobresalientes ) print ( lista_sb ) Cree un script llamado juego_adivinar_num.R que permita jugar a adivinar un n\u00famero aleatorio del 1 al 10. \u00bfSer\u00edas capaz de crear un cuaderno de R donde expliques el programa? Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 secreto <- sample ( 1 : 10 , 1 ) found <- TRUE while ( found ){ print ( \"Prueba un n\u00famero: \" ) n <- scan ( n = 1 ) if ( n < secreto ) { print ( \"El numero que has pensado es mayor\" ) } else { print ( \"El numero que has pensado es menor\" ) } if ( n == secreto ){ print ( \"\u00a1ACERTASTE!\" ) break } } Consulta en el siguiente fichero si tu cuaderno es correcto: juego_adivinar.Rmd Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Ejercicios complementarios"},{"location":"estructuras_datos/","text":"Vectores \u00b6 En lenguaje R, un vector corresponde a una conjunto ordenado de elementos que re\u00fanen la condici\u00f3n de pertenecer al mismo tipo de dato at\u00f3mico. Si comprobamos de nuevo el contenido de las variables que se han empleado hasta ahora como ejemplos, se aprecia una indicaci\u00f3n previa al valor asignado entre corchetes, tal que as\u00ed [1] , indicando que el primer elemento del vector corresponde al primer elemento del rengl\u00f3n que se muestra. Esto es porque R, por defecto, crea vectores de longitud 1 para nuestra variable. La forma de crear vectores de mayor longitud o introducir nuevos elementos al vector es mediante la funci\u00f3n c() , la cual concatena varios elementos del mismo tipo. Si los elementos del vector pertenecen a distintos tipos de datos, la funci\u00f3n realiza autom\u00e1ticamente la coerci\u00f3n de elementos siguiendo la jerarqu\u00eda character > complex > numeric > integer > logical . Esto puede ser modificado por la funci\u00f3n as. , como ya se ha mencionado anteriormente. Ejemplo 1 2 3 vector1 <- c ( FALSE , 1 , 1 ) vector2 <- c ( vector1 , \"a\" , 1 , FALSE ) vector3 <- c ( vector2 , vector1 ) Otras funciones como vector() y seq() son capaces de crear vectores. La primera genera un vector cuyos elementos son 0, FALSE o nada dependiendo del tipo de dato que se indique en el par\u00e9ntesis, al igual que el n\u00famero de componentes. En cuanto a seq() , genera una secuencia de tipo num\u00e9rico, al igual que el operador : . Sin embargo, esta funci\u00f3n permite realizar indicaciones mediante los argumentos que dispone. Ejemplos 1 2 3 4 5 vector4 <- vector ( \"character\" , 3 ) vector5 <- vector ( \"numeric\" , 3 ) vector6 <- vector ( \"logical\" , 3 ) vector7 <- -2.5 : 2.5 vector8 <- seq ( from = -2.5 , to = 2.5 , by = 2.5 ) Los elementos del vector pueden recibir un nombre que permite acceder a ellos a partir de \u00e9l. Esto se consigue de diversas formas: 1 2 3 4 names ( vector6 ) <- c ( \"dato1\" , \"dato2\" , \"dato3\" ) vector8 <- c ( dato1 = -2.5 , dato2 = 0 , dato3 = 2.5 ) vector6 [ \"dato2\" ] vector6 [ 2 ] Como se puede observar, la forma de acceder a los elementos de un vector es mediante el operador [] . En su interior se indica el nombre o la posici\u00f3n del elemento en el vector. Esto crea un subconjunto del vector, el cual puede someterse a modificaciones indipendientemente del resto de elementos, ya que cuando se opera con un vector sin se\u00f1alar un elemento, se transforma completamente. Ejemplos 1 2 3 vector8 [ 4 : 7 ] <- log ( vector8 [ 3 ]) vector9 <- vector8 * c ( 2 , 1 ) vector10 <- vector8 [ - ( 4 : 7 )] / 5 Info En el primer ejemplo, se opera con un elemento y el resultado se asigna a una secuencia de elementos que, inicialmente, no conformaban vector8 . Sin embargo, se puede extender la longitud de \u00e9ste y, por tanto, aumentar sus componentes mediante esta forma. Las posiciones que no se indican en situaciones similares a las de este ejemplo y se encuentran entre los nuevos elementos y aquellos que compon\u00edan el vector previamente, se introduce un valor no disponible NA . Los vectores pueden someterse a operaciones matem\u00e1ticamente permitidas para estas estructuras, por lo que se puede realizar c\u00e1lculos donde participan diversos vectores, aunque su longitud no sea la misma, como en el tercer ejemplo, donde se repiten los componentes del vector de menor longitud para operar, tal que as\u00ed c(2,1,2,1,2,1,2) . Se ignoran las posiciones de un vector cuando se emplea el signo negativo delante de \u00e9stas, como el \u00faltimo ejemplo. Cree un script llamado tabla_multiplicar.R que devuelva un vector con el resultado de la tabla de multiplicar de un n\u00famero. Respuesta 1 2 3 4 print ( \"\u00bfDe qu\u00e9 n\u00famero deseas conocer su tabla de multiplicar?\" ) numero <- scan ( n = 1 ) tabla <- c ( 0 : 10 ) * numero cat ( \"Resultados de la tabla de multiplicar del\" , numero , \":\" , tabla , \"\\n\" ) Una matriz es un conjunto de n\u00fameros que se disponen bidimensionalmente en filas y columnas. Desde el punto de vista del lenguaje R, una matriz es un vector num\u00e9rico con un atributo adicional: dim . Dicho atributo es un vector de dos elementos que indican, por este orden, el n\u00famero de renglones y columnas que componen esta estructura de datos. Predeterminadamente, los elementos son localizados por columnas, es decir, completando todas las filas de la primera columna y, posteriormente, las sucesivas columnas, hasta complementar cada coordenada. Se requiere que el n\u00famero de coordenadas sea id\u00e9ntico a la longitud del vector num\u00e9rico a partir del cual se genera la matriz. Por tanto, una de las formas de conseguir una matriz es creando dicho atributo del vector mediante dim() . 1 dim ( vector7 ) <- c ( 3 , 2 ) Adem\u00e1s de este modo, se puede obtener mediante funciones como matrix() , que permite indicar si la matriz se completa por columnas o filas, y rbind() o cbind , que propiamente seleccionan el m\u00e9todo de completar la matriz, por filas o columnas, respectivamente. En estas funciones no se requiere la longitud exacta, sino que se complementan repitiendo los elementos continuando con el mismo orden o, en caso de una longitud menor, finalizando la matriz con el elemento que corresponde por orden. Ejemplos 1 2 3 4 5 matriz1 <- matrix ( vector7 , nrow = 3 , ncol = 2 , , byrow = TRUE ) matriz2 <- rbind ( c ( -2.5 , 0 , 2.5 ), c ( -1 , 0 , 1 )) matriz3 <- cbind ( c ( -2.5 , 0 , 2.5 ), c ( -1 , 0 , 1 )) matriz4 <- cbind ( c ( -2.5 , 0 , 2.5 ), c ( -1 , 0 )) matriz5 <- cbind ( c ( -2.5 , 0 , 2.5 , 5 ), c ( -1 , 0 , 1 )) \u00bfQu\u00e9 destacar\u00edas si comparas mediante el operador == las matrices vector7 y matriz1 o matriz2 y matriz3 ? Respuesta Las matrices vector7 y matriz1 presentan las mismas dimensiones aunque se hayan creado de distinta forma. Esto es porque dim() indica las dimensiones tomando al primer elemento del vector como n\u00famero de filas y al segundo como columnas, de la misma forma que los argumentos nrow y ncol de matrix() . Sin embargo, se aprecia que matriz1 se ha completado distintamente debido a que se emplea el argumento byrow como TRUE . Esto se conseguir\u00eda igualmente usando el argumento bycol como FALSE . Usando las formas opuestas o ignorando estos argumentos, matriz1 y vector7 ser\u00edan id\u00e9nticos. Los elementos de matriz2 y matriz3 son los mismos n\u00fameros, sin embargo, se disponen de forma distinta, ya que se emplean diferentes funciones para combinar los vectores y obtener la matriz, pues rbind() sit\u00faa el primer vector en la primera fila, colocando sus elementos en columnas diferentes y, as\u00ed, con los dem\u00e1s vectores que componen la matriz. Al contrario ocurre con cbind() , que sit\u00faa los vectores en columnas, por lo que cada uno de sus elementos ocupa una fila diferente. Las columnas y las filas de las matrices, al igual que los vectores y las listas, pueden recibir un nombre que las identifique y funcione como \u00edndice. Esto se realiza mediante las funciones rownames() y colnames() . Para obtener un sobconjunto de la matriz se introduce el nombre o las coordenadas en el operador [] . En este tipo de estructuras se toma el total de una fila o columna cuando se ignora introducir su coordenada. Ejemplos 1 2 3 4 rownames ( matriz2 ) <- c ( \"fila1\" , \"fila2\" ) colnames ( matriz2 ) <- c ( \"columna1\" , \"columna2\" , \"columna3\" ) matriz2 [ 2 , \"columna1\" ] <- matriz2 [ 2 , \"columna1\" ] * 2 matriz6 <- matriz2 %*% matriz6 Info Las matrices pueden someterse a las operaciones matem\u00e1ticas que les caracterizan, como la multiplicaci\u00f3n matricial mediante el operador %*% o multiplicaci\u00f3n elemento por elemento * . Cree un script llamado matriz.R que devuelva una matriz de dimensiones y valores deseados. Respuesta 1 2 3 4 5 6 7 print ( \"\u00bfCu\u00e1ntas filas y columnas desea que tenga la matriz? Ind\u00edquelo de forma respectiva: \" ) dim_matriz <- scan ( n = 2 ) n_elementos <- dim_matriz [ 1 ] * dim_matriz [ 2 ] cat ( \"Indique\" , n_elementos , \"valores uno por uno como desees que se rellenen las filas de la matriz: \" ) elementos <- scan ( n = n_elementos ) matriz <- matrix ( elementos , nrow = dim_matriz [ 1 ], ncol = dim_matriz [ 2 ], byrow = TRUE ) print ( matriz ) Factores \u00b6 Este tipo de dato se consigue a partir de un vector mediante la funci\u00f3n factor() . Esto genera una estructura de datos que contiene los mismos elementos que el vector y, adem\u00e1s, informaci\u00f3n categ\u00f3rica de dichos elementos, de forma que sean identificados con etiquetas num\u00e9ricas, correspondientes a un \u00edndice, atendiendo al orden de aparici\u00f3n de la categor\u00eda en la longitud del vector. Dichas categor\u00edas se pueden ordenar como guste si se indica con un vector, que puede ser referido con el argumento levels , aunque no es necesario. Ejemplo 1 factor1 <- factor ( vector3 , c ( 1 , \"a\" , FALSE , 0 )) Info Se puede visualizar los elementos del factor y sus categor\u00edas simult\u00e1neamente con funciones como str() o unclass() , que tambi\u00e9n permiten observar componentes de otros tipos de datos; o bien s\u00f3lamente las categor\u00edas con levels() . Aplicando la funci\u00f3n table() al factor, se crea una tabla que indica la cantidad de elementos pertenecientes a cada categor\u00eda en el factor. 1 2 3 4 str ( factor1 ) unclass ( factor1 ) levels ( factor1 ) tabla1 <- table ( factor1 ) Para realizar subconjuntos de los elementos del factor se puede consultar tanto su posici\u00f3n en el factor como el \u00edndice de la categor\u00eda. Estos subconjuntos no se pueden someter a operaciones num\u00e9ricas. Ejemplos 1 2 subconjunto1 <- factor1 [ 3 ] subconjunto2 <- levels ( factor1 )[ 3 ] Cree un script llamado tabla_factor.R que devuelva una tabla indicando la cantidad de veces que se repite cada valor que introduzcas como entrada. Reespuesta 1 2 3 4 print ( \"Introduzca el valor que desee hasta que no quiera incluir m\u00e1s n\u00fameros: \" ) nums <- scan () tabla_nums <- table ( factor ( nums )) print ( tabla_nums ) Listas \u00b6 Una lista es una clase de datos que puede contener elementos de distinto tipo sin necesidad de coerci\u00f3n. Se obtiene mediante la funci\u00f3n list() y, al igual que en los vectores, se pueden nombrar sus componentes tanto directamente en el momento de creaci\u00f3n de la lista como a partir de la funci\u00f3n names() junto a c() para dar un nombre a los componentes, habiendo creado previamente la lista. Tambi\u00e9n ser\u00eda posible sustituyendo c() por list() . Para acceder a los elementos de la lista se pueden emplear los operadores [] , [[]] y $ . Estos dos \u00faltimos se utilizan con las nombres, aunque [[]] tambi\u00e9n puede emplearse con la localizaci\u00f3n, como [] , y la funci\u00f3n que tienen es extraer elementos de un objeto, con su clase original. Ejemplo 1 2 3 4 lista1 <- list ( equipo = \"verde\" , componentes = 2 , nombres = c ( \"Ana\" , \"Juan\" ), ganador = TRUE ) names ( lista1 ) <- list ( \"color\" , \"n\u00famero\" , \"usuario\" , \"perdedor\" ) subconjunto3 <- lista1 $ color subconjunto4 <- lista1 [ 1 ] Cree un script llamado nota_media.R que devuelva una lista con el nombre del usuario y la nota media actual del Grado. Respuesta 1 2 3 4 5 6 7 nombre_usuario <- readline ( prompt = \"Dime tu nombre: \" ) print ( \"\u00bfCu\u00e1ntas asignaturas has finalizado?\" ) num_asignaturas <- scan ( n = 1 ) print ( \"\u00bfQu\u00e9 notas finales obtuviste en ellas?\" ) notas <- scan ( n = num_asignaturas ) lista <- list ( nombre = nombre_usuario , nota_media = mean ( notas )) print ( lista ) Data frames \u00b6 Un data frame es una estructura de datos bidimensional que parece una tabla, aunque realmente act\u00faa como una lista, cuyos componentes pueden ser de diferentes tipos, como vectores, listas o matrices. Esta estructura requiere que coincida el n\u00famero de datos por fila y el tipo de dato de cada columna. Los data frames se pueden crear mediante la funci\u00f3n data.frame() , que ordena por columnas los datos que indicamos como componentes, y si la longitud de las filas resultase inferior o superior entre ellas, no se generar\u00eda el data frame, ya que no cumplir\u00eda las restricciones. Ejemplo 1 data_frame1 <- data.frame ( vector4 , vector5 , vector6 ) Los data frames pueden aumentar sus componentes mediante las funciones rbind() y cbind , siempre que se cumplan los requerimientos. Adem\u00e1s, las columnas y las filas pueden ser nombradas mediante colnames() y rownames() , respectivamente. Tambi\u00e9n se puede acceder a los elementos de la estructura y modificarlos, para ello se emplean los operadores [] , [[]] y $ . Ejemplos 1 2 3 4 5 data_frame1 <- cbind ( data_frame1 , c ( 1 , 2 , 3 )) colnames ( data_frame1 ) <- c ( \"caracter\" , \"numerico\" , \"logico\" , \"entero\" ) rownames ( data_frame1 ) <- c ( \"n1\" , \"n2\" , \"n3\" ) data_frame1 $ numerico <- c ( 1.5 , 2.5 , 3.5 ) data_frame1 [[ \"n2\" , \"logico\" ]] <- TRUE \u00bfQu\u00e9 diferencia hay entre lo que devuelve y lo que se podr\u00eda esperar en los siguientes casos? 1 2 data_frame1 [ 1 : 3 , \"cadena\" ] <- c ( \"si\" , \"si\" , \"no\" ) data_frame2 <- rbind ( data_frame1 , c ( \"no\" , 4.5 , TRUE , 4 )) Respuesta En el primer caso, en lugar de los nuevos caracteres indicados que podr\u00edamos esperar situados en la primera columna, correspondiente a cadena , se encuentran datos no disponibles NA . Esto se debe a que los vectores de caracteres se transforman en factores para que sea posible su tratamiento mediante operaciones estad\u00edsticas. Por tanto, al introducir una nueva cadena, no la reconoce, ya que previamente requiere su categorizaci\u00f3n con la funci\u00f3n levels() , lo que resultar\u00eda del siguiente modo: 1 2 levels ( data_frame1 $ cadena ) <- c ( levels ( data_frame1 $ cadena ), \"si\" , \"no\" ) data_frame1 [ 1 : 3 , \"cadena\" ] <- c ( \"si\" , \"si\" , \"no\" ) En cuanto a data_frame2 , a simple vista parece devolver lo esperado. No obstante, si se comprueba el contenido de cada columna, observamos que los datos han cambiado a tipo car\u00e1cter. Esto ocurre porque se introduce un vector con un elemento de tipo car\u00e1cter, que lo convierte los dem\u00e1s datos en dicho tipo por coerci\u00f3n, y como ya se ha mencionado, las columas deben de contener la misma clase de dato, por lo que tambi\u00e9n se produce coerci\u00f3n en sus componentes. Esto repercutir\u00eda en las operaciones a las que podr\u00eda someterse. El m\u00e9todo de evadir este error ser\u00eda introduciendo los elementos como lista y no como vector, de forma que mantenga el tipo de dato en sus componentes. Para ello, se sustituye la funci\u00f3n c() por list() , tal que as\u00ed: 1 data_frame3 <- rbind ( data_frame1 , list ( \"no\" , 4.5 , TRUE , 4 )) Cree un script llamado data_frame.R que devuelva un data frame partiendo de matriz.R. Respuesta 1 2 3 source ( \"matriz.R\" ) df <- data.frame ( matriz ) print ( df ) Funciones de inter\u00e9s En el apartado de Conceptos b\u00e1sicos se comentaron algunas funciones iniciales de utilidad. Otras que podr\u00edan resultar interesantes son las siguientes: Nombre Funci\u00f3n sample() Ofrece un n\u00famero de muestras aleatorias indicadas rnorm() Crea un vector num\u00e9rico cuya longitud y media son indicados unique() Elimina elementos repetidos de un vector sort() Ordena los elementos del vector tabulate() Cuenta las veces que se repite un elemento match() Devuelve un vector con las posiciones de las similitudes entre vectores max() Indica el elemento cuyo valor es el m\u00e1s grande min() Indica el elemento cuyo valor es el m\u00e1s peque\u00f1o which.max() Indica la posici\u00f3n del elemento cuyo valor es el m\u00e1s grande which.min() Indica la posici\u00f3n del elemento cuyo valor es el m\u00e1s peque\u00f1o t() Realiza la matriz traspuesta diag() Extrae los elementos de la primera diagonal de la matriz -diag() Extrae los elementos de la diagonal opuesta de la matriz det() Determinante de la matriz Cree un script llamado moda.R que realice la moda de un vector num\u00e9rico. Respuesta 1 2 3 4 5 6 7 print ( \"Indique los valores num\u00e9ricos del vector: \" ) V <- scan () uV <- sort ( unique ( V )) # Elimina duplicaciones y ordena Ht <- tabulate ( match ( V , uV )) # Histograma dado pos_max <- which.max ( Ht ) # Posicion del max moda <- uV [ pos_max ] # Toma el valor m\u00e1s repetido cat ( \"La moda del vector es\" , moda , \"\\n\" ) Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Estructuras de datos"},{"location":"estructuras_datos/#vectores","text":"En lenguaje R, un vector corresponde a una conjunto ordenado de elementos que re\u00fanen la condici\u00f3n de pertenecer al mismo tipo de dato at\u00f3mico. Si comprobamos de nuevo el contenido de las variables que se han empleado hasta ahora como ejemplos, se aprecia una indicaci\u00f3n previa al valor asignado entre corchetes, tal que as\u00ed [1] , indicando que el primer elemento del vector corresponde al primer elemento del rengl\u00f3n que se muestra. Esto es porque R, por defecto, crea vectores de longitud 1 para nuestra variable. La forma de crear vectores de mayor longitud o introducir nuevos elementos al vector es mediante la funci\u00f3n c() , la cual concatena varios elementos del mismo tipo. Si los elementos del vector pertenecen a distintos tipos de datos, la funci\u00f3n realiza autom\u00e1ticamente la coerci\u00f3n de elementos siguiendo la jerarqu\u00eda character > complex > numeric > integer > logical . Esto puede ser modificado por la funci\u00f3n as. , como ya se ha mencionado anteriormente. Ejemplo 1 2 3 vector1 <- c ( FALSE , 1 , 1 ) vector2 <- c ( vector1 , \"a\" , 1 , FALSE ) vector3 <- c ( vector2 , vector1 ) Otras funciones como vector() y seq() son capaces de crear vectores. La primera genera un vector cuyos elementos son 0, FALSE o nada dependiendo del tipo de dato que se indique en el par\u00e9ntesis, al igual que el n\u00famero de componentes. En cuanto a seq() , genera una secuencia de tipo num\u00e9rico, al igual que el operador : . Sin embargo, esta funci\u00f3n permite realizar indicaciones mediante los argumentos que dispone. Ejemplos 1 2 3 4 5 vector4 <- vector ( \"character\" , 3 ) vector5 <- vector ( \"numeric\" , 3 ) vector6 <- vector ( \"logical\" , 3 ) vector7 <- -2.5 : 2.5 vector8 <- seq ( from = -2.5 , to = 2.5 , by = 2.5 ) Los elementos del vector pueden recibir un nombre que permite acceder a ellos a partir de \u00e9l. Esto se consigue de diversas formas: 1 2 3 4 names ( vector6 ) <- c ( \"dato1\" , \"dato2\" , \"dato3\" ) vector8 <- c ( dato1 = -2.5 , dato2 = 0 , dato3 = 2.5 ) vector6 [ \"dato2\" ] vector6 [ 2 ] Como se puede observar, la forma de acceder a los elementos de un vector es mediante el operador [] . En su interior se indica el nombre o la posici\u00f3n del elemento en el vector. Esto crea un subconjunto del vector, el cual puede someterse a modificaciones indipendientemente del resto de elementos, ya que cuando se opera con un vector sin se\u00f1alar un elemento, se transforma completamente. Ejemplos 1 2 3 vector8 [ 4 : 7 ] <- log ( vector8 [ 3 ]) vector9 <- vector8 * c ( 2 , 1 ) vector10 <- vector8 [ - ( 4 : 7 )] / 5 Info En el primer ejemplo, se opera con un elemento y el resultado se asigna a una secuencia de elementos que, inicialmente, no conformaban vector8 . Sin embargo, se puede extender la longitud de \u00e9ste y, por tanto, aumentar sus componentes mediante esta forma. Las posiciones que no se indican en situaciones similares a las de este ejemplo y se encuentran entre los nuevos elementos y aquellos que compon\u00edan el vector previamente, se introduce un valor no disponible NA . Los vectores pueden someterse a operaciones matem\u00e1ticamente permitidas para estas estructuras, por lo que se puede realizar c\u00e1lculos donde participan diversos vectores, aunque su longitud no sea la misma, como en el tercer ejemplo, donde se repiten los componentes del vector de menor longitud para operar, tal que as\u00ed c(2,1,2,1,2,1,2) . Se ignoran las posiciones de un vector cuando se emplea el signo negativo delante de \u00e9stas, como el \u00faltimo ejemplo. Cree un script llamado tabla_multiplicar.R que devuelva un vector con el resultado de la tabla de multiplicar de un n\u00famero. Respuesta 1 2 3 4 print ( \"\u00bfDe qu\u00e9 n\u00famero deseas conocer su tabla de multiplicar?\" ) numero <- scan ( n = 1 ) tabla <- c ( 0 : 10 ) * numero cat ( \"Resultados de la tabla de multiplicar del\" , numero , \":\" , tabla , \"\\n\" ) Una matriz es un conjunto de n\u00fameros que se disponen bidimensionalmente en filas y columnas. Desde el punto de vista del lenguaje R, una matriz es un vector num\u00e9rico con un atributo adicional: dim . Dicho atributo es un vector de dos elementos que indican, por este orden, el n\u00famero de renglones y columnas que componen esta estructura de datos. Predeterminadamente, los elementos son localizados por columnas, es decir, completando todas las filas de la primera columna y, posteriormente, las sucesivas columnas, hasta complementar cada coordenada. Se requiere que el n\u00famero de coordenadas sea id\u00e9ntico a la longitud del vector num\u00e9rico a partir del cual se genera la matriz. Por tanto, una de las formas de conseguir una matriz es creando dicho atributo del vector mediante dim() . 1 dim ( vector7 ) <- c ( 3 , 2 ) Adem\u00e1s de este modo, se puede obtener mediante funciones como matrix() , que permite indicar si la matriz se completa por columnas o filas, y rbind() o cbind , que propiamente seleccionan el m\u00e9todo de completar la matriz, por filas o columnas, respectivamente. En estas funciones no se requiere la longitud exacta, sino que se complementan repitiendo los elementos continuando con el mismo orden o, en caso de una longitud menor, finalizando la matriz con el elemento que corresponde por orden. Ejemplos 1 2 3 4 5 matriz1 <- matrix ( vector7 , nrow = 3 , ncol = 2 , , byrow = TRUE ) matriz2 <- rbind ( c ( -2.5 , 0 , 2.5 ), c ( -1 , 0 , 1 )) matriz3 <- cbind ( c ( -2.5 , 0 , 2.5 ), c ( -1 , 0 , 1 )) matriz4 <- cbind ( c ( -2.5 , 0 , 2.5 ), c ( -1 , 0 )) matriz5 <- cbind ( c ( -2.5 , 0 , 2.5 , 5 ), c ( -1 , 0 , 1 )) \u00bfQu\u00e9 destacar\u00edas si comparas mediante el operador == las matrices vector7 y matriz1 o matriz2 y matriz3 ? Respuesta Las matrices vector7 y matriz1 presentan las mismas dimensiones aunque se hayan creado de distinta forma. Esto es porque dim() indica las dimensiones tomando al primer elemento del vector como n\u00famero de filas y al segundo como columnas, de la misma forma que los argumentos nrow y ncol de matrix() . Sin embargo, se aprecia que matriz1 se ha completado distintamente debido a que se emplea el argumento byrow como TRUE . Esto se conseguir\u00eda igualmente usando el argumento bycol como FALSE . Usando las formas opuestas o ignorando estos argumentos, matriz1 y vector7 ser\u00edan id\u00e9nticos. Los elementos de matriz2 y matriz3 son los mismos n\u00fameros, sin embargo, se disponen de forma distinta, ya que se emplean diferentes funciones para combinar los vectores y obtener la matriz, pues rbind() sit\u00faa el primer vector en la primera fila, colocando sus elementos en columnas diferentes y, as\u00ed, con los dem\u00e1s vectores que componen la matriz. Al contrario ocurre con cbind() , que sit\u00faa los vectores en columnas, por lo que cada uno de sus elementos ocupa una fila diferente. Las columnas y las filas de las matrices, al igual que los vectores y las listas, pueden recibir un nombre que las identifique y funcione como \u00edndice. Esto se realiza mediante las funciones rownames() y colnames() . Para obtener un sobconjunto de la matriz se introduce el nombre o las coordenadas en el operador [] . En este tipo de estructuras se toma el total de una fila o columna cuando se ignora introducir su coordenada. Ejemplos 1 2 3 4 rownames ( matriz2 ) <- c ( \"fila1\" , \"fila2\" ) colnames ( matriz2 ) <- c ( \"columna1\" , \"columna2\" , \"columna3\" ) matriz2 [ 2 , \"columna1\" ] <- matriz2 [ 2 , \"columna1\" ] * 2 matriz6 <- matriz2 %*% matriz6 Info Las matrices pueden someterse a las operaciones matem\u00e1ticas que les caracterizan, como la multiplicaci\u00f3n matricial mediante el operador %*% o multiplicaci\u00f3n elemento por elemento * . Cree un script llamado matriz.R que devuelva una matriz de dimensiones y valores deseados. Respuesta 1 2 3 4 5 6 7 print ( \"\u00bfCu\u00e1ntas filas y columnas desea que tenga la matriz? Ind\u00edquelo de forma respectiva: \" ) dim_matriz <- scan ( n = 2 ) n_elementos <- dim_matriz [ 1 ] * dim_matriz [ 2 ] cat ( \"Indique\" , n_elementos , \"valores uno por uno como desees que se rellenen las filas de la matriz: \" ) elementos <- scan ( n = n_elementos ) matriz <- matrix ( elementos , nrow = dim_matriz [ 1 ], ncol = dim_matriz [ 2 ], byrow = TRUE ) print ( matriz )","title":"Vectores"},{"location":"estructuras_datos/#factores","text":"Este tipo de dato se consigue a partir de un vector mediante la funci\u00f3n factor() . Esto genera una estructura de datos que contiene los mismos elementos que el vector y, adem\u00e1s, informaci\u00f3n categ\u00f3rica de dichos elementos, de forma que sean identificados con etiquetas num\u00e9ricas, correspondientes a un \u00edndice, atendiendo al orden de aparici\u00f3n de la categor\u00eda en la longitud del vector. Dichas categor\u00edas se pueden ordenar como guste si se indica con un vector, que puede ser referido con el argumento levels , aunque no es necesario. Ejemplo 1 factor1 <- factor ( vector3 , c ( 1 , \"a\" , FALSE , 0 )) Info Se puede visualizar los elementos del factor y sus categor\u00edas simult\u00e1neamente con funciones como str() o unclass() , que tambi\u00e9n permiten observar componentes de otros tipos de datos; o bien s\u00f3lamente las categor\u00edas con levels() . Aplicando la funci\u00f3n table() al factor, se crea una tabla que indica la cantidad de elementos pertenecientes a cada categor\u00eda en el factor. 1 2 3 4 str ( factor1 ) unclass ( factor1 ) levels ( factor1 ) tabla1 <- table ( factor1 ) Para realizar subconjuntos de los elementos del factor se puede consultar tanto su posici\u00f3n en el factor como el \u00edndice de la categor\u00eda. Estos subconjuntos no se pueden someter a operaciones num\u00e9ricas. Ejemplos 1 2 subconjunto1 <- factor1 [ 3 ] subconjunto2 <- levels ( factor1 )[ 3 ] Cree un script llamado tabla_factor.R que devuelva una tabla indicando la cantidad de veces que se repite cada valor que introduzcas como entrada. Reespuesta 1 2 3 4 print ( \"Introduzca el valor que desee hasta que no quiera incluir m\u00e1s n\u00fameros: \" ) nums <- scan () tabla_nums <- table ( factor ( nums )) print ( tabla_nums )","title":"Factores"},{"location":"estructuras_datos/#listas","text":"Una lista es una clase de datos que puede contener elementos de distinto tipo sin necesidad de coerci\u00f3n. Se obtiene mediante la funci\u00f3n list() y, al igual que en los vectores, se pueden nombrar sus componentes tanto directamente en el momento de creaci\u00f3n de la lista como a partir de la funci\u00f3n names() junto a c() para dar un nombre a los componentes, habiendo creado previamente la lista. Tambi\u00e9n ser\u00eda posible sustituyendo c() por list() . Para acceder a los elementos de la lista se pueden emplear los operadores [] , [[]] y $ . Estos dos \u00faltimos se utilizan con las nombres, aunque [[]] tambi\u00e9n puede emplearse con la localizaci\u00f3n, como [] , y la funci\u00f3n que tienen es extraer elementos de un objeto, con su clase original. Ejemplo 1 2 3 4 lista1 <- list ( equipo = \"verde\" , componentes = 2 , nombres = c ( \"Ana\" , \"Juan\" ), ganador = TRUE ) names ( lista1 ) <- list ( \"color\" , \"n\u00famero\" , \"usuario\" , \"perdedor\" ) subconjunto3 <- lista1 $ color subconjunto4 <- lista1 [ 1 ] Cree un script llamado nota_media.R que devuelva una lista con el nombre del usuario y la nota media actual del Grado. Respuesta 1 2 3 4 5 6 7 nombre_usuario <- readline ( prompt = \"Dime tu nombre: \" ) print ( \"\u00bfCu\u00e1ntas asignaturas has finalizado?\" ) num_asignaturas <- scan ( n = 1 ) print ( \"\u00bfQu\u00e9 notas finales obtuviste en ellas?\" ) notas <- scan ( n = num_asignaturas ) lista <- list ( nombre = nombre_usuario , nota_media = mean ( notas )) print ( lista )","title":"Listas"},{"location":"estructuras_datos/#data-frames","text":"Un data frame es una estructura de datos bidimensional que parece una tabla, aunque realmente act\u00faa como una lista, cuyos componentes pueden ser de diferentes tipos, como vectores, listas o matrices. Esta estructura requiere que coincida el n\u00famero de datos por fila y el tipo de dato de cada columna. Los data frames se pueden crear mediante la funci\u00f3n data.frame() , que ordena por columnas los datos que indicamos como componentes, y si la longitud de las filas resultase inferior o superior entre ellas, no se generar\u00eda el data frame, ya que no cumplir\u00eda las restricciones. Ejemplo 1 data_frame1 <- data.frame ( vector4 , vector5 , vector6 ) Los data frames pueden aumentar sus componentes mediante las funciones rbind() y cbind , siempre que se cumplan los requerimientos. Adem\u00e1s, las columnas y las filas pueden ser nombradas mediante colnames() y rownames() , respectivamente. Tambi\u00e9n se puede acceder a los elementos de la estructura y modificarlos, para ello se emplean los operadores [] , [[]] y $ . Ejemplos 1 2 3 4 5 data_frame1 <- cbind ( data_frame1 , c ( 1 , 2 , 3 )) colnames ( data_frame1 ) <- c ( \"caracter\" , \"numerico\" , \"logico\" , \"entero\" ) rownames ( data_frame1 ) <- c ( \"n1\" , \"n2\" , \"n3\" ) data_frame1 $ numerico <- c ( 1.5 , 2.5 , 3.5 ) data_frame1 [[ \"n2\" , \"logico\" ]] <- TRUE \u00bfQu\u00e9 diferencia hay entre lo que devuelve y lo que se podr\u00eda esperar en los siguientes casos? 1 2 data_frame1 [ 1 : 3 , \"cadena\" ] <- c ( \"si\" , \"si\" , \"no\" ) data_frame2 <- rbind ( data_frame1 , c ( \"no\" , 4.5 , TRUE , 4 )) Respuesta En el primer caso, en lugar de los nuevos caracteres indicados que podr\u00edamos esperar situados en la primera columna, correspondiente a cadena , se encuentran datos no disponibles NA . Esto se debe a que los vectores de caracteres se transforman en factores para que sea posible su tratamiento mediante operaciones estad\u00edsticas. Por tanto, al introducir una nueva cadena, no la reconoce, ya que previamente requiere su categorizaci\u00f3n con la funci\u00f3n levels() , lo que resultar\u00eda del siguiente modo: 1 2 levels ( data_frame1 $ cadena ) <- c ( levels ( data_frame1 $ cadena ), \"si\" , \"no\" ) data_frame1 [ 1 : 3 , \"cadena\" ] <- c ( \"si\" , \"si\" , \"no\" ) En cuanto a data_frame2 , a simple vista parece devolver lo esperado. No obstante, si se comprueba el contenido de cada columna, observamos que los datos han cambiado a tipo car\u00e1cter. Esto ocurre porque se introduce un vector con un elemento de tipo car\u00e1cter, que lo convierte los dem\u00e1s datos en dicho tipo por coerci\u00f3n, y como ya se ha mencionado, las columas deben de contener la misma clase de dato, por lo que tambi\u00e9n se produce coerci\u00f3n en sus componentes. Esto repercutir\u00eda en las operaciones a las que podr\u00eda someterse. El m\u00e9todo de evadir este error ser\u00eda introduciendo los elementos como lista y no como vector, de forma que mantenga el tipo de dato en sus componentes. Para ello, se sustituye la funci\u00f3n c() por list() , tal que as\u00ed: 1 data_frame3 <- rbind ( data_frame1 , list ( \"no\" , 4.5 , TRUE , 4 )) Cree un script llamado data_frame.R que devuelva un data frame partiendo de matriz.R. Respuesta 1 2 3 source ( \"matriz.R\" ) df <- data.frame ( matriz ) print ( df ) Funciones de inter\u00e9s En el apartado de Conceptos b\u00e1sicos se comentaron algunas funciones iniciales de utilidad. Otras que podr\u00edan resultar interesantes son las siguientes: Nombre Funci\u00f3n sample() Ofrece un n\u00famero de muestras aleatorias indicadas rnorm() Crea un vector num\u00e9rico cuya longitud y media son indicados unique() Elimina elementos repetidos de un vector sort() Ordena los elementos del vector tabulate() Cuenta las veces que se repite un elemento match() Devuelve un vector con las posiciones de las similitudes entre vectores max() Indica el elemento cuyo valor es el m\u00e1s grande min() Indica el elemento cuyo valor es el m\u00e1s peque\u00f1o which.max() Indica la posici\u00f3n del elemento cuyo valor es el m\u00e1s grande which.min() Indica la posici\u00f3n del elemento cuyo valor es el m\u00e1s peque\u00f1o t() Realiza la matriz traspuesta diag() Extrae los elementos de la primera diagonal de la matriz -diag() Extrae los elementos de la diagonal opuesta de la matriz det() Determinante de la matriz Cree un script llamado moda.R que realice la moda de un vector num\u00e9rico. Respuesta 1 2 3 4 5 6 7 print ( \"Indique los valores num\u00e9ricos del vector: \" ) V <- scan () uV <- sort ( unique ( V )) # Elimina duplicaciones y ordena Ht <- tabulate ( match ( V , uV )) # Histograma dado pos_max <- which.max ( Ht ) # Posicion del max moda <- uV [ pos_max ] # Toma el valor m\u00e1s repetido cat ( \"La moda del vector es\" , moda , \"\\n\" ) Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Data frames"},{"location":"funciones/","text":"Creaci\u00f3n de funciones documentadas \u00b6 Las funciones constituyen un tipo de objeto que act\u00faa como una herramienta para agrupar varias operaciones. El modelo de creaci\u00f3n de una funci\u00f3n es el siguiente: 1 2 3 nombre_funcion <- function ( argumentos ) { operaciones } Los argumentos son las variables que participan en las operaciones y permiten que les sean asignados los elementos que el usuario desee que sean sometidos a las operaciones de la funci\u00f3n, los cuales pueden ser incluso otras funciones. La asignaci\u00f3n de la funci\u00f3n a una variable se conoce como definici\u00f3n de la funci\u00f3n. El nombre asignado, que no puede ser id\u00e9ntico a funciones existentes o palabras reservadas ni contener espacios, se emplear\u00e1 como llamada de ella, tal que as\u00ed: 1 nombre_funcion ( argumentos = elementos ) No obstante, si la funci\u00f3n se ha guardado en un script, primeramente se debe cargar la funci\u00f3n con source() . Cuando se corre una funci\u00f3n, \u00e9sta devuelve como resultado el \u00faltimo valor calculado. Si bien, se recomienda indicar en las operaciones aquello que se pretende obtener de ella mediante la instrucci\u00f3n return() , que interrumpe su ejecuci\u00f3n y devuelve el argumento que contenga dicha instrucci\u00f3n. En las operaciones de la funci\u00f3n se pueden incluir condiciones para que se devuelva un error si el elemento que el usuario quiera someter a dicha funci\u00f3n no cumple determinados requisitos. Esto se consigue con la funci\u00f3n stopifnot() o estructuras de control como construcciones if-else y la funci\u00f3n stop() . Adem\u00e1s de este tipo de errores, la ejecuci\u00f3n de la funci\u00f3n puede derivar en otros muchos errores, por lo que es importante incluir comentarios (#) o crear documentaci\u00f3n para la funci\u00f3n dise\u00f1ada. Esto es recomendable hacerlo mediante el sistema de documentaci\u00f3n Roxygen y se debe guardar en formato .Rd para que la descripci\u00f3n aparezca cuando se consulte la ayuda de la funci\u00f3n. Ejemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #' @title Grados Farenheit a Celsius (cent\u00edgrados) #' @description #' \\code{farenheit_a_celsius} calcula los respectivos grados Celsius de Farenheit indicados. #' @param f Vector num\u00e9rico de longitud uno y valor superior a -460. #' @return Muestra calculada en grados Celsius (Vector num\u00e9rico de longitud uno). #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' farenheit_a_celsius(0) #' @export farenheit_a_celsius <- function ( f ) { if ( ! is.numeric ( f )) { stop ( \"f no es un vector numeric.\" ) } stopifnot ( f > -460 ) #0 absoluto centigrados <- (( f -32 ) * ( 5 / 9 )) return ( centigrados ) } En el apartado Variables, objetos at\u00f3micos y operadores se realizaron los scripts Kelvin_a_Celsius.R y pesetas_a_euros.R. Modifique los scripts para que el programa no se ejecute si los grados son inferiores al cero absoluto y las pesetas son negativas. \u00bfQu\u00e9 has incluido en los scripts? Respuesta 1 2 3 4 5 if ( kelvin < 0 ) { stop ( \"Inferior a 0 absoluto.\" ) } stopifnot ( pesetas > 0 ) Cree un script llamado moda.R que defina una funci\u00f3n para conocer la moda de un vector num\u00e9rico. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #' @title Moda #' @description #' \\code{moda} calcula la moda del vector num\u00e9rico indicado. #' @param V Vector num\u00e9rico #' @return Vector num\u00e9rico de longitud uno con el valor de la moda. #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' moda(c(3,4,2,3,5,4,5,6,2,4,3)) #' @export moda <- function ( V ) { uV <- sort ( unique ( V )) # Elimina duplicaciones y ordena Ht <- tabulate ( match ( V , uV )) # Histograma dado pos_max <- which.max ( Ht ) # Posicion del max moda <- uV [ pos_max ] # Toma el valor m\u00e1s repetido return ( moda ) } Ejercicios complementarios \u00b6 Cree un script llamado \"ecuacion_parabola.R\" que defina una funci\u00f3n que aplique la ecuaci\u00f3n de la parabola a un valor x. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #' @title C\u00e1lculo de la ecuaci\u00f3n de una par\u00e1bola. #' @description #' \\code{ecuacion_parabola} calcula el valor y de la ecuaci\u00f3n de una par\u00e1bola. #' @param x: valor x; a: t\u00e9rmino cuadr\u00e1tico; b: t\u00e9rmino lineal; c: t\u00e9rmino independiente #' @return Vector num\u00e9rico de longitud uno con el valor de y. #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' ecuacion_parabola(c(2,1,3,2)) #' @export ecuacion_parabola <- function ( x , a , b , c ) { y <- a * x ^ 2 + b * x + c return ( y ) } Cree un script llamado segundo_grado.R que defina una funci\u00f3n para resolver una ecuaci\u00f3n de segundo grado tipo ax^2 + bx + c. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #' @title C\u00e1lculo de la ecuaci\u00f3n de segundo grado. #' @description #' \\code{segundo_grado} calcula la inc\u00f3gnita de una ecuaci\u00f3n de segundo grado. #' @param a: t\u00e9rmino cuadr\u00e1tico; b: t\u00e9rmino lineal; c: t\u00e9rmino independiente #' @return Dos vectores num\u00e9ricos de longitud uno con el valor de la inc\u00f3gnita. #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' ecuacion_parabola(c(1,3,2)) #' @export segundo_grado <- function ( a , b , c ) { if ( ! is.numeric ( a ) | ! is.numeric ( b ) | ! is.numeric ( c )) { stop ( \"Alg\u00fan argumento no es un vector numeric.\" ) } num_para_sqrt <- b ^ 2 - 4 * a * c stopifnot ( num_para_sqrt >= 0 ) x1 <- ( - b + sqrt ( num_para_sqrt )) / ( 2 * a ) x2 <- ( - b - sqrt ( num_para_sqrt )) / ( 2 * a ) return ( c ( x1 , x2 )) } Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba . R, RStudio y R-Commander: gu\u00eda introductoria. Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez & Jos\u00e9 Diz P\u00e9rez .","title":"Funciones"},{"location":"funciones/#creacion-de-funciones-documentadas","text":"Las funciones constituyen un tipo de objeto que act\u00faa como una herramienta para agrupar varias operaciones. El modelo de creaci\u00f3n de una funci\u00f3n es el siguiente: 1 2 3 nombre_funcion <- function ( argumentos ) { operaciones } Los argumentos son las variables que participan en las operaciones y permiten que les sean asignados los elementos que el usuario desee que sean sometidos a las operaciones de la funci\u00f3n, los cuales pueden ser incluso otras funciones. La asignaci\u00f3n de la funci\u00f3n a una variable se conoce como definici\u00f3n de la funci\u00f3n. El nombre asignado, que no puede ser id\u00e9ntico a funciones existentes o palabras reservadas ni contener espacios, se emplear\u00e1 como llamada de ella, tal que as\u00ed: 1 nombre_funcion ( argumentos = elementos ) No obstante, si la funci\u00f3n se ha guardado en un script, primeramente se debe cargar la funci\u00f3n con source() . Cuando se corre una funci\u00f3n, \u00e9sta devuelve como resultado el \u00faltimo valor calculado. Si bien, se recomienda indicar en las operaciones aquello que se pretende obtener de ella mediante la instrucci\u00f3n return() , que interrumpe su ejecuci\u00f3n y devuelve el argumento que contenga dicha instrucci\u00f3n. En las operaciones de la funci\u00f3n se pueden incluir condiciones para que se devuelva un error si el elemento que el usuario quiera someter a dicha funci\u00f3n no cumple determinados requisitos. Esto se consigue con la funci\u00f3n stopifnot() o estructuras de control como construcciones if-else y la funci\u00f3n stop() . Adem\u00e1s de este tipo de errores, la ejecuci\u00f3n de la funci\u00f3n puede derivar en otros muchos errores, por lo que es importante incluir comentarios (#) o crear documentaci\u00f3n para la funci\u00f3n dise\u00f1ada. Esto es recomendable hacerlo mediante el sistema de documentaci\u00f3n Roxygen y se debe guardar en formato .Rd para que la descripci\u00f3n aparezca cuando se consulte la ayuda de la funci\u00f3n. Ejemplo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #' @title Grados Farenheit a Celsius (cent\u00edgrados) #' @description #' \\code{farenheit_a_celsius} calcula los respectivos grados Celsius de Farenheit indicados. #' @param f Vector num\u00e9rico de longitud uno y valor superior a -460. #' @return Muestra calculada en grados Celsius (Vector num\u00e9rico de longitud uno). #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' farenheit_a_celsius(0) #' @export farenheit_a_celsius <- function ( f ) { if ( ! is.numeric ( f )) { stop ( \"f no es un vector numeric.\" ) } stopifnot ( f > -460 ) #0 absoluto centigrados <- (( f -32 ) * ( 5 / 9 )) return ( centigrados ) } En el apartado Variables, objetos at\u00f3micos y operadores se realizaron los scripts Kelvin_a_Celsius.R y pesetas_a_euros.R. Modifique los scripts para que el programa no se ejecute si los grados son inferiores al cero absoluto y las pesetas son negativas. \u00bfQu\u00e9 has incluido en los scripts? Respuesta 1 2 3 4 5 if ( kelvin < 0 ) { stop ( \"Inferior a 0 absoluto.\" ) } stopifnot ( pesetas > 0 ) Cree un script llamado moda.R que defina una funci\u00f3n para conocer la moda de un vector num\u00e9rico. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #' @title Moda #' @description #' \\code{moda} calcula la moda del vector num\u00e9rico indicado. #' @param V Vector num\u00e9rico #' @return Vector num\u00e9rico de longitud uno con el valor de la moda. #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' moda(c(3,4,2,3,5,4,5,6,2,4,3)) #' @export moda <- function ( V ) { uV <- sort ( unique ( V )) # Elimina duplicaciones y ordena Ht <- tabulate ( match ( V , uV )) # Histograma dado pos_max <- which.max ( Ht ) # Posicion del max moda <- uV [ pos_max ] # Toma el valor m\u00e1s repetido return ( moda ) }","title":"Creaci\u00f3n de funciones documentadas"},{"location":"funciones/#ejercicios-complementarios","text":"Cree un script llamado \"ecuacion_parabola.R\" que defina una funci\u00f3n que aplique la ecuaci\u00f3n de la parabola a un valor x. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #' @title C\u00e1lculo de la ecuaci\u00f3n de una par\u00e1bola. #' @description #' \\code{ecuacion_parabola} calcula el valor y de la ecuaci\u00f3n de una par\u00e1bola. #' @param x: valor x; a: t\u00e9rmino cuadr\u00e1tico; b: t\u00e9rmino lineal; c: t\u00e9rmino independiente #' @return Vector num\u00e9rico de longitud uno con el valor de y. #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' ecuacion_parabola(c(2,1,3,2)) #' @export ecuacion_parabola <- function ( x , a , b , c ) { y <- a * x ^ 2 + b * x + c return ( y ) } Cree un script llamado segundo_grado.R que defina una funci\u00f3n para resolver una ecuaci\u00f3n de segundo grado tipo ax^2 + bx + c. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #' @title C\u00e1lculo de la ecuaci\u00f3n de segundo grado. #' @description #' \\code{segundo_grado} calcula la inc\u00f3gnita de una ecuaci\u00f3n de segundo grado. #' @param a: t\u00e9rmino cuadr\u00e1tico; b: t\u00e9rmino lineal; c: t\u00e9rmino independiente #' @return Dos vectores num\u00e9ricos de longitud uno con el valor de la inc\u00f3gnita. #' #' @author Ismael S\u00e1nchez Pareja #' #' @examples #' ecuacion_parabola(c(1,3,2)) #' @export segundo_grado <- function ( a , b , c ) { if ( ! is.numeric ( a ) | ! is.numeric ( b ) | ! is.numeric ( c )) { stop ( \"Alg\u00fan argumento no es un vector numeric.\" ) } num_para_sqrt <- b ^ 2 - 4 * a * c stopifnot ( num_para_sqrt >= 0 ) x1 <- ( - b + sqrt ( num_para_sqrt )) / ( 2 * a ) x2 <- ( - b - sqrt ( num_para_sqrt )) / ( 2 * a ) return ( c ( x1 , x2 )) } Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba . R, RStudio y R-Commander: gu\u00eda introductoria. Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez & Jos\u00e9 Diz P\u00e9rez .","title":"Ejercicios complementarios"},{"location":"graficacion/","text":"R contiene un sistema de generaci\u00f3n de gr\u00e1ficas en la biblioteca base de funciones, incluida predeterminadamente en la instalaci\u00f3n de R. Si bien, existen otros paquetes interesantes por el salto de calidad o facilidad que ofrecen para la graficaci\u00f3n, como ggplot2 o lattice . Graficando con R base : plot() \u00b6 La funci\u00f3n m\u00e1s b\u00e1sica y general es plot() . En la llamada a la funci\u00f3n es imprescindible indicar el eje x para generar una gr\u00e1fica. El eje y es opcional. Ambos ejes deben ser vectores que, seg\u00fan el tipo de dato que contengan, se generar\u00eda un tipo de gr\u00e1fico diferente, el cual pueden ser ajustado mediante argumentos que controlan el aspecto, como type (tipo de gr\u00e1fico), main (t\u00edtulo), xlab , ylab (etiquetas de los ejes), col ( color ) y pch (tipo de puntos). Los tipos de datos y las gr\u00e1ficas que generar\u00edan son: Continuo: vector num\u00e9rico, entero, l\u00f3gico o complejo. Discreto: vector de factores o cadenas de texto. x y Gr\u00e1fico Continuo Continuo Diagrama de dispersi\u00f3n (Scatterplot) Continuo Ninguno Diagrama de sectores Discreto Continuo Diagrama de caja (Box plot) Discreto Ninguno Gr\u00e1fica de barras e Histograma Ninguno Cualquiera Error Las indicaciones que se pueden realizar en type y pch son muy variadas: type= Tipo de gr\u00e1fico \u201cp\u201d puntos \u201cl\u201d l\u00edneas \u201cb\u201d puntos y l\u00edneas seccionadas \u201cc\u201d s\u00f3lo las l\u00edneas de type=\u201db\u201d \u201co\u201d puntos y l\u00edneas \u201ch\u201d L\u00edneas verticales \u201cs\u201d funci\u00f3n escalera (horizontal a vertical) \u201cS\u201d funci\u00f3n escalera (vertical a horizontal) pch= Tipo de punto * * . . o o O O 0 0 + + - - # # Info El tipo de gr\u00e1fico de puntos y l\u00edneas creado por type=\"b\" tambi\u00e9n se obtiene incluyendo la funci\u00f3n abline() tras plot() , que agregar\u00eda la recta de regresi\u00f3n a los puntos incluidos inicialmente. Si bien, puede servir para adicionar rectas diferentes al gr\u00e1fico. La cantidad de tipos de punto es mucho mayor ya que, incluyendo n\u00fameros entre el 0 y 25 en lugar de los observados en la tabla, se consigue puntos de diversas formas geom\u00e9tricas pudiendo ser coloreados en su interior. La funci\u00f3n curve() crea representaciones a partir de funciones. Ejemplos 1 2 plot ( 1 : 5 , seq ( from = 1 , to = 9 , by = 2 ), type = \"o\" , main = \"T\u00edtulo del ejemplo\" , xlab = \"etiqueta eje x\" , ylab = \"etiqueta eje y\" , col = c ( \"red\" ), pch = \"*\" ) abline ( 5 , 1 ) 1 curve ( sin , 2 * pi , -2 * pi , xname = \"x\" ) Agregaci\u00f3n de leyenda \u00b6 La funci\u00f3n legend() permite incluir leyenda al gr\u00e1fico. Esta funci\u00f3n se puede situar dentro de la funci\u00f3n que genere el gr\u00e1fico, siempre al final, e incluye diferentes argumentos como x (ubicaci\u00f3n: bottomright, bottom, bottomleft, left, topleft, top, topright, right, center), legend (etiquetas), fill (colores de las etiquetas) y title (t\u00edtulo de la leyenda). Ejemplo 1 2 plot ( c ( 1 , 2 , 3 , 4 , 5 ), c ( 1 , 3 , 5 , 7 , 9 ), type = \"b\" , main = \"T\u00edtulo del ejemplo\" , xlab = \"etiqueta eje x\" , ylab = \"etiqueta eje y\" , col = c ( \"blue\" ), pch = 0 ) legend ( x = \"bottomright\" , legend = c ( \"Punto\" , \"Recta regresi\u00f3n\" ), fill = \"blue\" , title = \"Leyenda ejemplo\" ) Exportaci\u00f3n como imagen \u00b6 Los gr\u00e1ficos creados no pueden ser guardados en el ambiente, sino que es necesario salvar cada gr\u00e1fico como archivo JPG, PNG, PDF o alg\u00fan otro tipo, mediante funciones como jpeg() , png() o pdf() , respectivamente, las cuales presentan argumentos como filename (nombre y ruta del archivo), width (anchura de imagen) o height (altura de imagen). Estos dos \u00faltimos por defecto en p\u00edxeles. Estas funciones se sit\u00faan previo a la creaci\u00f3n del gr\u00e1fico. Finalmente, se incluye la funci\u00f3n dev.off() , que cierra el archivo y permite finalizar el guardado de \u00e9ste para continuar con otras graficaciones. El resultado puede observase con la funci\u00f3n file.show() , incluyendo la ruta del archivo entre comillas. Info Los argumentos filename , main , xlab , ylab , x y title requieren comillas para realizar el ajuste. Ejemplo 1 2 3 4 jpeg ( filename = \"ejemplo.jpg\" , width = 500 , height = 500 ) plot ( c ( 1 , 2 , 3 , 4 , 5 ), c ( 1 , 3 , 5 , 7 , 9 ), type = \"b\" , main = \"T\u00edtulo del ejemplo\" , xlab = \"etiqueta eje x\" , ylab = \"etiqueta eje y\" , col = c ( \"blue\" ), pch = 0 ) legend ( x = \"bottomright\" , legend = c ( \"Punto\" , \"Recta regresi\u00f3n\" ), fill = \"blue\" , title = \"Leyenda ejemplo\" ) dev.off () Gr\u00e1fico de barras \u00b6 Este tipo de gr\u00e1fica representa la frecuencia observada de los datos de una variable discreta como barras, una para cada categor\u00eda de la variable. La gr\u00e1fica de barras puede obtenerse a partir de la funci\u00f3n plot() si se realiza con un vector de factor o cadena de texto como x y no se incluye y . Sin embargo, la forma de conseguir este gr\u00e1fico de una forma m\u00e1s simple y directa es mediante la funci\u00f3n barplot() que, adem\u00e1s ofrece la posibilidad de representar tablas de contingencia, recibiendo como argumento una matriz o una tabla obtenida con la funci\u00f3n table() . Ejemplo plot() 1 2 3 jpeg ( filename = \"ejemplo_barra_plot.jpg\" , width = 500 , height = 500 ) plot ( factor ( c ( \"A\" , \"T\" , \"A\" , \"G\" , \"A\" , \"C\" , \"G\" )), main = \"Frecuencia ADN\" , xlab = \"bases\" , ylab = \"cantidad\" , col = c ( \"blue\" , \"red\" , \"green\" , \"orange\" )) dev.off () Ejemplo plot() de tabla 1 2 3 4 5 jpeg ( filename = \"ejemplo_plot_table.jpg\" , width = 500 , height = 500 ) bases <- factor ( c ( \"A\" , \"T\" , \"A\" , \"G\" , \"A\" , \"C\" , \"G\" ), c ( \"A\" , \"T\" , \"G\" , \"C\" )) tabla_bases <- table ( bases ) plot ( tabla_bases , main = \"Frecuencia ADN\" , xlab = \"bases\" , ylab = \"cantidad\" ) dev.off () Ejemplo barplot() 1 2 3 4 5 6 7 8 matriz_bases <- matrix ( c ( 1 , 3 , 2 , 1 ), 1 ) matriz_bases <- rbind ( matriz_bases , c ( 2 , 2 , 1 , 3 )) rownames ( matriz_bases ) <- c ( \"adn1\" , \"adn2\" ) colnames ( matriz_bases ) <- c ( \"A\" , \"T\" , \"C\" , \"G\" ) jpeg ( filename = \"ejemplo_barplot.jpg\" , , width = 500 , height = 500 ) barplot ( matriz_bases , beside = T , main = \"Frecuencia ADN\" , xlab = \"cantidad\" , ylab = \"bases\" , col = c ( \"seagreen\" , \"purple\" ), horiz = T ) legend ( x = \"bottomright\" , legend = c ( \"adn1\" , \"adn2\" ), fill = c ( \"seagreen\" , \"purple\" ), title = \"Leyenda \" ) dev.off () Info El argumento beside=T permite situar las diferentes barras que componen una categor\u00eda de forma paralela en lugar de vertical, es decir, sustituye un gr\u00e1fico de barras apiladas por apareadas. El argumento horiz=T coloca el gr\u00e1fico de barras horizontalmente. Cree un script llamado bases_hebras.R que devuelva un gr\u00e1fico de barras que divida las bases de la hebra introducida y la complementaria. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library ( \"stringr\" ) hebra_cod <- readline ( prompt = \"Indique la hebra codificante: \" ) hebra_molde <- str_replace_all ( hebra_cod , c ( \"A\" = \"t\" , \"G\" = \"c\" , \"C\" = \"G\" , \"T\" = \"A\" )) hebra_molde <- str_to_upper ( hebra_molde ) cadena_cod <- strsplit ( hebra_cod , \"\" ) [[ 1 ]] cadena_molde <- strsplit ( hebra_molde , \"\" ) [[ 1 ]] bases_cod <- sort ( unique ( cadena_cod )) bases_molde <- sort ( unique ( cadena_molde )) v_hebra_cod <- 1 : length ( bases_cod ) v_hebra_molde <- 1 : length ( bases_molde ) for ( i in 1 : length ( bases_cod )){ v_hebra_cod [ i ] <- str_count ( hebra_cod , bases_cod [ i ]) v_hebra_molde [ i ] <- str_count ( hebra_molde , bases_molde [ i ]) } matriz_hebras <- matrix ( v_hebra_cod , 1 ) matriz_hebras <- rbind ( matriz_hebras , v_hebra_molde ) colnames ( matriz_hebras ) <- bases_cod rownames ( matriz_hebras ) <- c ( \"hebra codificante\" , \"hebra molde\" ) jpeg ( filename = \"bases_hebras.jpg\" , width = 500 , height = 500 ) barplot ( matriz_hebras , main = \"Frecuencia nucle\u00f3tidos\" , xlab = \"bases\" , ylab = \"cantidad\" , col = c ( \"blue\" , \"orange\" )) legend ( x = \"topright\" , legend = c ( \"hebra codificante\" , \"hebra molde\" ), fill = c ( \"blue\" , \"orange\" ), title = \"Leyenda \" ) dev.off () file.show ( \"bases_hebras.jpg\" ) Histograma \u00b6 Un histograma es una gr\u00e1fica muy similar al gr\u00e1fico de barras, ya que muestra frecuencias de datos. La principal diferencia radica en que muestra el n\u00famero de veces que se observa el dato en un rango determinado, mientras que el gr\u00e1fico de barras lo realiza por categor\u00eda. Adem\u00e1s, el histograma no permite dejar espacios entre las barras. La forma de crear un histograma es mediante la funci\u00f3n hist() , la cual requiere un vector num\u00e9rico como argumento x . El argumento br delimita los rangos si son indicados mediante un vector num\u00e9rico. Ejemplo 1 2 3 jpeg ( filename = \"ejemplo_hist.jpg\" , width = 500 , height = 500 ) hist ( rnorm ( 20 , 5 : 10 ), br = c ( 2 , 4 , 6 , 8 , 10 , 12 ), main = \"Histograma\" , xlab = \"Rangos\" , ylab = \"Frecuencia\" , col = c ( \"moccasin\" , \"lightsteelblue\" , \"darkolivegreen1\" , \"chocolate\" , \"antiquewhite\" )) dev.off () Cree un script llamado hist_notas.R que devuelva un histograma del conjunto de notas medias de la clase. Respuesta 1 2 3 4 5 6 print ( \"Nota media de los alumnos de la clase: \" ) n_medias <- scan () jpeg ( filename = \"n_medias_hist.jpg\" , width = 500 , height = 500 ) hist ( n_medias , br = c ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ), main = \"Histograma notas medias\" , xlab = \"Rangos notas medias\" , ylab = \"Frecuencia de alumnos\" , col = c ( \"moccasin\" , \"lightsteelblue\" , \"darkolivegreen\" , \"chocolate\" , \"antiquewhite\" , \"springgreen\" , \"steelblue\" , \"tan\" , \"snow\" , \"thistle\" )) dev.off () file.show ( \"n_medias_hist.jpg\" ) Diagrama de dispersi\u00f3n \u00b6 El diagrama de dispersi\u00f3n muestra la relaci\u00f3n entre dos variables num\u00e9ricas continuas mediante intersecciones entre ellas, por lo que se emplean los argumentos x e y en la funci\u00f3n plot() para situar las variables en los ejes de coordenadas. Normalmente, este tipo de gr\u00e1fico incluye una recta de regresi\u00f3n. Para ello se utiliza la funci\u00f3n lm(y~x) . Ejemplo 1 2 3 4 5 6 7 jpeg ( filename = \"ejemplo_disp.jpg\" , width = 500 , height = 500 ) x1 <- rnorm ( 50 , 4 : 7 ) y1 <- rnorm ( 50 , 11 : 14 ) plot ( x1 , y1 , main = \"Diagrama de dispersi\u00f3n: Ki y Vmax\" , xlab = \"Ki\" , ylab = \"Vmax\" ) regresion <- lm ( y1 ~ x1 ) abline ( regresion , col = \"red\" ) dev.off () Cree un script llamado recta_calibrado.R que devuelva el diagrama de dispersi\u00f3n y la recta de calibrado de \u00e9ste. Respuesta 1 2 3 4 5 6 7 8 9 10 11 print ( \"Indique las concentraciones utilizadas (nM): \" ) x_conc <- scan () print ( \"Indique los pH obtenidos: \" ) y_pH <- scan () jpeg ( filename = \"recta_calibrado.jpg\" , width = 500 , height = 500 ) plot ( x_conc , y_conc main = \"Recta de calibrado\" , xlab = \"Concentraci\u00f3n (mM)\" , ylab = \"pH\" ) r_calibrado <- lm ( y_pH ~ x_conc ) print ( r_calibrado ) abline ( r_calibrado , col = \"blue\" ) dev.off () file.show ( \"recta_calibrado.jpg\" ) Diagrama de caja \u00b6 El diagrama de caja es una gr\u00e1fica que incluye un rect\u00e1ngulo cuya base inferior es el cuartil 1 (Q1, 25% de los datos) y la base superior el cuartil 3 (Q3, 75% de los datos). El intervalo entre Q3 y Q1 se conoce como rango intercuart\u00edlico (RIC). La divisi\u00f3n de este rect\u00e1ngulo corresponde al cuartil 2 o mediana (Q2, 50% de los datos). Adem\u00e1s, incluye una l\u00ednea que indica el rango de valores no at\u00edpicos, es decir, superiores a Q1\u20131.5\u00b7RIC o inferiores a Q3+1.5\u00b7RIC. Los puntos que sobresalen de estos l\u00edmites son los valores at\u00edpicos. Este gr\u00e1fico tan representativo se obtiene mediante la funci\u00f3n boxplot() . Para ello se necesita precisar la variable continua que se grafica y la variable que se emplea para agrupar, esto es, y y x mediante formula = y ~ x . Ejemplo boxplot() 1 2 3 jpeg ( filename = \"ejemplo_boxplot.jpg\" , width = 500 , height = 500 ) boxplot ( formula = c ( 40 , 20 , 15 , 17 , 10 , 33 , 22 , 36 , 28 , 25 , 42 ) ~ c ( \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"B\" ), main = \"Caja con plot()\" , xlab = \"x\" , ylab = \"y\" , col = c ( \"blue\" , \"red\" )) dev.off () Cree un script llamado notas_grupos.R que genere un gr\u00e1fico de cajas que compare las notas medias de dos grupos de clase distintos Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 print ( \"Indique el n\u00famero de alumnos: \" ) n_alumnos <- scan ( n = 1 ) v_notas <- 1 : n_alumnos v_grupos <- 1 : n_alumnos for ( i in 1 : n_alumnos ){ v_grupos [ i ] <- readline ( prompt = \"Indique el grupo: \" ) print ( \"Nota media del alumno correspondiente: \" ) v_notas [ i ] <- scan ( n = 1 ) } jpeg ( filename = \"notas_grupos_boxplot.jpg\" , width = 500 , height = 500 ) boxplot ( formula = v_notas ~ v_grupos , main = \"Notas medias de los grupos de clase \" , xlab = \"Grupos\" , ylab = \"Notas\" , col = c ( \"grey\" , \"seagreen\" )) dev.off () file.show ( \"notas_grupos_boxplot.jpg\" ) Gr\u00e1fico de sectores \u00b6 El gr\u00e1fico de sectores, tambi\u00e9n conocido como diagrama de pastel o tarta, es un gr\u00e1fico circular que se emplea para representar porcentajes y proporciones. Su creaci\u00f3n se lleva a cabo mediante la funci\u00f3n pie() que recibe como argumento principal un vector (o tabla) con las frecuencias absolutas de cada clase. Se utiliza el argumento labels para cambiar las etiquetas de cada sector. Para ello toma un vector de cadenas de caracteres. Ejemplo 1 2 3 jpeg ( filename = \"ejemplo_pastel.jpg\" , width = 500 , height = 500 ) pie ( c ( 0.15 , 0.35 , 0.20 , 0.30 ), label = c ( \"A\" , \"B\" , \"C\" , \"D\" ), col = c ( \"red\" , \"yellow\" , \"orange\" , \"brown\" ), main = \"Gr\u00e1fico de sectores\" ) dev.off () Cree un script llamado frecuencia_bases.R que devuelva un gr\u00e1fico de sectores sobre el porcentaje de bases de la cadena de ADN indicada. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 library ( \"stringr\" ) cad_adn <- readline ( prompt = \"Indique la cadena de ADN: \" ) cad_split <- strsplit ( cad_adn , \"\" ) [[ 1 ]] cad_sort <- sort ( unique ( cad_split )) v_f_cad <- 1 : length ( cad_sort ) for ( i in 1 : length ( cad_sort )){ v_f_cad [ i ] <- str_count ( cad_adn , cad_sort [ i ]) / length ( cad_split ) } jpeg ( filename = \"pastel_f_bases.jpg\" , width = 500 , height = 500 ) pie ( v_f_cad , label = cad_sort , col = c ( \"red\" , \"blue\" , \"green\" , \"yellow\" ), main = \"Frecuencia de bases\" ) dev.off () file.show ( \"pastel_f_bases.jpg\" ) Graficaci\u00f3n avanzada con ggplot2 \u00b6 Como se ha comentado al inicio, existen varios paquetes que incrementan la calidad de los gr\u00e1ficos y pueden facilitar el acceso a los datos a graficar. Entre ellos destacan ggplot2 o lattice , empleados para graficar con data frames de un modo avanzado. Este apartado se centra \u00fanicamente en introducir al alumno en el uso de ggplot2 , contenido en la librer\u00eda tidyverse , ya que es el m\u00e1s extendido de los dos. Ambos son muy similares y se solapan en funcionalidades, si bien, ggplot2 es m\u00e1s reciente que lattice . Para entender su funcionamiento se va a utilizar uno de los ficheros utilizados en Importaci\u00f3n y exportaci\u00f3n de datos : csv_tutorial.csv . 1 2 df_csv <- read.csv ( file = \"csv_tutorial.csv\" ) library ( \"ggplot2\" ) La funci\u00f3n b\u00e1sica de ggplot2 para generar un gr\u00e1fico es ggplot() . Atendiendo al contenido del objeto al que se le emplee la funci\u00f3n, se producir\u00e1 un determinado tipo de gr\u00e1fico. No obstante, ggplot() permite aplicar internamente la funci\u00f3n aes() , lo que en la terminolog\u00eda de este paquete se refiere a est\u00e9ticas, es decir, color, distancia horizontal o vertical, forma o tama\u00f1o del punto, etc. Estas est\u00e9ticas se asocian a columnas de datos, de modo que se establezcan seg\u00fan la columna asociada. La forma de representar los datos y las est\u00e9ticas se indican por lo que se conoce como capas en la terminolog\u00eda de ggplot2 . Las capas, como se deduce de su nombre, pueden superponerse. Esto es posible orden\u00e1ndolas como si de una suma se tratase. Existe una gran cantidad de capas, aunque las m\u00e1s usuales son las referidas a gr\u00e1ficos estudiados durante esta secci\u00f3n, como geom_point() , geom_line() , geom_histogram() , geom_bar() o geom_boxplot . Aqu\u00ed puede consultar una lista de las capas disponibles. Como ocurre con R base , cada tipo de gr\u00e1fico, en este caso capa, exige que las variables sean continuas o discretas atendiendo a lo que representa. Ejemplos 1 ejemplo_ggplot <- ggplot ( df_csv , aes ( x = cmo , y = rmsd , col = protb )) + geom_point () + geom_smooth ( method = \"loess\" , se = F ) 1 ejemplo_ggplot2 <- ggplot(df_csv, aes(x = cmo, y = rmsd, col = rmsd)) + geom_point() + geom_smooth(method=\"lm\", col=\"red\") 1 ggplot_boxplot <- ggplot(df_csv, aes(x=protb, y = rmsd, fill=protb)) + geom_boxplot() 1 ggplot_density <- ggplot(df_csv, aes(x=cmo)) + geom_density(aes(fill=protb), position = \"stack\") Las est\u00e9ticas del gr\u00e1fico puede ser modificadas de forma que aparezca el t\u00edtulo y las etiquetas deseadas. Para ello se emplean las funciones ggtitle() y labs() , respectivamente. Ejemplo 1 ejemplo_ggplot3 <- ejemplo_ggplot + ggtitle ( \"Ejemplo con ggplot2: RMSD vs CMO\" ) + labs ( x = \"CMO\" , y = \"RMSD\" , colour = \"RMSD\" ) Otra de las caracter\u00edsticas resaltables de ggplot2 es su capacidad para presentar gr\u00e1ficos conjuntos que hayan sido divididos respecto a diferentes categor\u00edas de una variable mediante facetas como facet_grid() . Adem\u00e1s, ofrece la posibilidad de cambiar de tema, es decir, el aspecto est\u00e9tico del gr\u00e1fico que no tiene que ver con los datos. El paquete contiene diversos temas b\u00e1sicos, pero se pueden instalar librer\u00edas que expandan el n\u00famero con temas m\u00e1s espec\u00edficos, como el paquete ggthemes . Las diversas herramientas que ofrece ggplot2 hacen que la calidad de gr\u00e1fico que permite crear sea incre\u00edble, muestra de ello se puede observar en diversas webs ofrecidas en los enlaces de inter\u00e9s. Ejemplos 1 ggplot_density2 <- ggplot_density + facet_grid ( ~ protb ) 1 ejemplo_ggplot4 <- ejemplo_ggplot2 + theme_wsj() 1 ggplot_density3 <- ggplot_density2 + theme_wsj() Finalmente, el gr\u00e1fico creado se puede exportar a un archivo de extensi\u00f3n PNG , JPG u otros tipos si se indica el formato en el nombre del archivo dentro de la funci\u00f3n ggsave() . Ejemplo 1 ggsave ( \"gg_density_wsj.png\" ) Ejercicio complementario \u00b6 Ejercicio resumen El archivo graf_resumen.Rmd contiene un ejercicio de graficaci\u00f3n sobre el conjunto de datos DNase disponible de R, el cual se asemeja a los datos que el alumno puede recoger en una t\u00edpica pr\u00e1ctica del Grado. DNase se carga directamente introduciendo dicho nombre entre comillas en la funci\u00f3n data() . Adem\u00e1s, incluye otro ejercicio sobre los siguientes datos de una clase: clase_resumen.csv . De esta manera se pretende resumir de forma explicativa lo estudiado en este apartado, por lo que requiere la instalaci\u00f3n de la biblioteca tidyverse . Ejemplo complementario de lattice: boxplot \u00b6 Ejemplo complementario: boxplot b\u00e1sico con lattice 1 2 3 4 library ( lattice ) jpeg ( filename = \"caja_lattice.jpg\" , width = 500 , height = 500 ) bwplot ( c ( \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"B\" ) ~ c ( 40 , 20 , 15 , 17 , 10 , 33 , 22 , 36 , 28 , 25 , 42 ), main = \"Caja con lattice\" , xlab = \"x\" , ylab = \"y\" , col = c ( \"blue\" , \"red\" )) dev.off () Enlaces de inter\u00e9s R para principiantes. Juan Bosco Mendoza Vega . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba . Nociones generales sobre R. M. Vargas , Universidad de Granada . Colors in R. T. Zheng , Columbia University . R para profesionales de los datos: una introducci\u00f3n. Carlos J. Gil Bellosta . Ejemplos de gr\u00e1ficas Ggplot2 con tema personalizado. El Blog de pmoracho Introducci\u00f3n a la Graficaci\u00f3n con ggplot2. Ronald Delgado","title":"Graficaci\u00f3n"},{"location":"graficacion/#graficando-con-r-base-plot","text":"La funci\u00f3n m\u00e1s b\u00e1sica y general es plot() . En la llamada a la funci\u00f3n es imprescindible indicar el eje x para generar una gr\u00e1fica. El eje y es opcional. Ambos ejes deben ser vectores que, seg\u00fan el tipo de dato que contengan, se generar\u00eda un tipo de gr\u00e1fico diferente, el cual pueden ser ajustado mediante argumentos que controlan el aspecto, como type (tipo de gr\u00e1fico), main (t\u00edtulo), xlab , ylab (etiquetas de los ejes), col ( color ) y pch (tipo de puntos). Los tipos de datos y las gr\u00e1ficas que generar\u00edan son: Continuo: vector num\u00e9rico, entero, l\u00f3gico o complejo. Discreto: vector de factores o cadenas de texto. x y Gr\u00e1fico Continuo Continuo Diagrama de dispersi\u00f3n (Scatterplot) Continuo Ninguno Diagrama de sectores Discreto Continuo Diagrama de caja (Box plot) Discreto Ninguno Gr\u00e1fica de barras e Histograma Ninguno Cualquiera Error Las indicaciones que se pueden realizar en type y pch son muy variadas: type= Tipo de gr\u00e1fico \u201cp\u201d puntos \u201cl\u201d l\u00edneas \u201cb\u201d puntos y l\u00edneas seccionadas \u201cc\u201d s\u00f3lo las l\u00edneas de type=\u201db\u201d \u201co\u201d puntos y l\u00edneas \u201ch\u201d L\u00edneas verticales \u201cs\u201d funci\u00f3n escalera (horizontal a vertical) \u201cS\u201d funci\u00f3n escalera (vertical a horizontal) pch= Tipo de punto * * . . o o O O 0 0 + + - - # # Info El tipo de gr\u00e1fico de puntos y l\u00edneas creado por type=\"b\" tambi\u00e9n se obtiene incluyendo la funci\u00f3n abline() tras plot() , que agregar\u00eda la recta de regresi\u00f3n a los puntos incluidos inicialmente. Si bien, puede servir para adicionar rectas diferentes al gr\u00e1fico. La cantidad de tipos de punto es mucho mayor ya que, incluyendo n\u00fameros entre el 0 y 25 en lugar de los observados en la tabla, se consigue puntos de diversas formas geom\u00e9tricas pudiendo ser coloreados en su interior. La funci\u00f3n curve() crea representaciones a partir de funciones. Ejemplos 1 2 plot ( 1 : 5 , seq ( from = 1 , to = 9 , by = 2 ), type = \"o\" , main = \"T\u00edtulo del ejemplo\" , xlab = \"etiqueta eje x\" , ylab = \"etiqueta eje y\" , col = c ( \"red\" ), pch = \"*\" ) abline ( 5 , 1 ) 1 curve ( sin , 2 * pi , -2 * pi , xname = \"x\" )","title":"Graficando con R base: plot()"},{"location":"graficacion/#agregacion-de-leyenda","text":"La funci\u00f3n legend() permite incluir leyenda al gr\u00e1fico. Esta funci\u00f3n se puede situar dentro de la funci\u00f3n que genere el gr\u00e1fico, siempre al final, e incluye diferentes argumentos como x (ubicaci\u00f3n: bottomright, bottom, bottomleft, left, topleft, top, topright, right, center), legend (etiquetas), fill (colores de las etiquetas) y title (t\u00edtulo de la leyenda). Ejemplo 1 2 plot ( c ( 1 , 2 , 3 , 4 , 5 ), c ( 1 , 3 , 5 , 7 , 9 ), type = \"b\" , main = \"T\u00edtulo del ejemplo\" , xlab = \"etiqueta eje x\" , ylab = \"etiqueta eje y\" , col = c ( \"blue\" ), pch = 0 ) legend ( x = \"bottomright\" , legend = c ( \"Punto\" , \"Recta regresi\u00f3n\" ), fill = \"blue\" , title = \"Leyenda ejemplo\" )","title":"Agregaci\u00f3n de leyenda"},{"location":"graficacion/#exportacion-como-imagen","text":"Los gr\u00e1ficos creados no pueden ser guardados en el ambiente, sino que es necesario salvar cada gr\u00e1fico como archivo JPG, PNG, PDF o alg\u00fan otro tipo, mediante funciones como jpeg() , png() o pdf() , respectivamente, las cuales presentan argumentos como filename (nombre y ruta del archivo), width (anchura de imagen) o height (altura de imagen). Estos dos \u00faltimos por defecto en p\u00edxeles. Estas funciones se sit\u00faan previo a la creaci\u00f3n del gr\u00e1fico. Finalmente, se incluye la funci\u00f3n dev.off() , que cierra el archivo y permite finalizar el guardado de \u00e9ste para continuar con otras graficaciones. El resultado puede observase con la funci\u00f3n file.show() , incluyendo la ruta del archivo entre comillas. Info Los argumentos filename , main , xlab , ylab , x y title requieren comillas para realizar el ajuste. Ejemplo 1 2 3 4 jpeg ( filename = \"ejemplo.jpg\" , width = 500 , height = 500 ) plot ( c ( 1 , 2 , 3 , 4 , 5 ), c ( 1 , 3 , 5 , 7 , 9 ), type = \"b\" , main = \"T\u00edtulo del ejemplo\" , xlab = \"etiqueta eje x\" , ylab = \"etiqueta eje y\" , col = c ( \"blue\" ), pch = 0 ) legend ( x = \"bottomright\" , legend = c ( \"Punto\" , \"Recta regresi\u00f3n\" ), fill = \"blue\" , title = \"Leyenda ejemplo\" ) dev.off ()","title":"Exportaci\u00f3n como imagen"},{"location":"graficacion/#grafico-de-barras","text":"Este tipo de gr\u00e1fica representa la frecuencia observada de los datos de una variable discreta como barras, una para cada categor\u00eda de la variable. La gr\u00e1fica de barras puede obtenerse a partir de la funci\u00f3n plot() si se realiza con un vector de factor o cadena de texto como x y no se incluye y . Sin embargo, la forma de conseguir este gr\u00e1fico de una forma m\u00e1s simple y directa es mediante la funci\u00f3n barplot() que, adem\u00e1s ofrece la posibilidad de representar tablas de contingencia, recibiendo como argumento una matriz o una tabla obtenida con la funci\u00f3n table() . Ejemplo plot() 1 2 3 jpeg ( filename = \"ejemplo_barra_plot.jpg\" , width = 500 , height = 500 ) plot ( factor ( c ( \"A\" , \"T\" , \"A\" , \"G\" , \"A\" , \"C\" , \"G\" )), main = \"Frecuencia ADN\" , xlab = \"bases\" , ylab = \"cantidad\" , col = c ( \"blue\" , \"red\" , \"green\" , \"orange\" )) dev.off () Ejemplo plot() de tabla 1 2 3 4 5 jpeg ( filename = \"ejemplo_plot_table.jpg\" , width = 500 , height = 500 ) bases <- factor ( c ( \"A\" , \"T\" , \"A\" , \"G\" , \"A\" , \"C\" , \"G\" ), c ( \"A\" , \"T\" , \"G\" , \"C\" )) tabla_bases <- table ( bases ) plot ( tabla_bases , main = \"Frecuencia ADN\" , xlab = \"bases\" , ylab = \"cantidad\" ) dev.off () Ejemplo barplot() 1 2 3 4 5 6 7 8 matriz_bases <- matrix ( c ( 1 , 3 , 2 , 1 ), 1 ) matriz_bases <- rbind ( matriz_bases , c ( 2 , 2 , 1 , 3 )) rownames ( matriz_bases ) <- c ( \"adn1\" , \"adn2\" ) colnames ( matriz_bases ) <- c ( \"A\" , \"T\" , \"C\" , \"G\" ) jpeg ( filename = \"ejemplo_barplot.jpg\" , , width = 500 , height = 500 ) barplot ( matriz_bases , beside = T , main = \"Frecuencia ADN\" , xlab = \"cantidad\" , ylab = \"bases\" , col = c ( \"seagreen\" , \"purple\" ), horiz = T ) legend ( x = \"bottomright\" , legend = c ( \"adn1\" , \"adn2\" ), fill = c ( \"seagreen\" , \"purple\" ), title = \"Leyenda \" ) dev.off () Info El argumento beside=T permite situar las diferentes barras que componen una categor\u00eda de forma paralela en lugar de vertical, es decir, sustituye un gr\u00e1fico de barras apiladas por apareadas. El argumento horiz=T coloca el gr\u00e1fico de barras horizontalmente. Cree un script llamado bases_hebras.R que devuelva un gr\u00e1fico de barras que divida las bases de la hebra introducida y la complementaria. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 library ( \"stringr\" ) hebra_cod <- readline ( prompt = \"Indique la hebra codificante: \" ) hebra_molde <- str_replace_all ( hebra_cod , c ( \"A\" = \"t\" , \"G\" = \"c\" , \"C\" = \"G\" , \"T\" = \"A\" )) hebra_molde <- str_to_upper ( hebra_molde ) cadena_cod <- strsplit ( hebra_cod , \"\" ) [[ 1 ]] cadena_molde <- strsplit ( hebra_molde , \"\" ) [[ 1 ]] bases_cod <- sort ( unique ( cadena_cod )) bases_molde <- sort ( unique ( cadena_molde )) v_hebra_cod <- 1 : length ( bases_cod ) v_hebra_molde <- 1 : length ( bases_molde ) for ( i in 1 : length ( bases_cod )){ v_hebra_cod [ i ] <- str_count ( hebra_cod , bases_cod [ i ]) v_hebra_molde [ i ] <- str_count ( hebra_molde , bases_molde [ i ]) } matriz_hebras <- matrix ( v_hebra_cod , 1 ) matriz_hebras <- rbind ( matriz_hebras , v_hebra_molde ) colnames ( matriz_hebras ) <- bases_cod rownames ( matriz_hebras ) <- c ( \"hebra codificante\" , \"hebra molde\" ) jpeg ( filename = \"bases_hebras.jpg\" , width = 500 , height = 500 ) barplot ( matriz_hebras , main = \"Frecuencia nucle\u00f3tidos\" , xlab = \"bases\" , ylab = \"cantidad\" , col = c ( \"blue\" , \"orange\" )) legend ( x = \"topright\" , legend = c ( \"hebra codificante\" , \"hebra molde\" ), fill = c ( \"blue\" , \"orange\" ), title = \"Leyenda \" ) dev.off () file.show ( \"bases_hebras.jpg\" )","title":"Gr\u00e1fico de barras"},{"location":"graficacion/#histograma","text":"Un histograma es una gr\u00e1fica muy similar al gr\u00e1fico de barras, ya que muestra frecuencias de datos. La principal diferencia radica en que muestra el n\u00famero de veces que se observa el dato en un rango determinado, mientras que el gr\u00e1fico de barras lo realiza por categor\u00eda. Adem\u00e1s, el histograma no permite dejar espacios entre las barras. La forma de crear un histograma es mediante la funci\u00f3n hist() , la cual requiere un vector num\u00e9rico como argumento x . El argumento br delimita los rangos si son indicados mediante un vector num\u00e9rico. Ejemplo 1 2 3 jpeg ( filename = \"ejemplo_hist.jpg\" , width = 500 , height = 500 ) hist ( rnorm ( 20 , 5 : 10 ), br = c ( 2 , 4 , 6 , 8 , 10 , 12 ), main = \"Histograma\" , xlab = \"Rangos\" , ylab = \"Frecuencia\" , col = c ( \"moccasin\" , \"lightsteelblue\" , \"darkolivegreen1\" , \"chocolate\" , \"antiquewhite\" )) dev.off () Cree un script llamado hist_notas.R que devuelva un histograma del conjunto de notas medias de la clase. Respuesta 1 2 3 4 5 6 print ( \"Nota media de los alumnos de la clase: \" ) n_medias <- scan () jpeg ( filename = \"n_medias_hist.jpg\" , width = 500 , height = 500 ) hist ( n_medias , br = c ( 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ), main = \"Histograma notas medias\" , xlab = \"Rangos notas medias\" , ylab = \"Frecuencia de alumnos\" , col = c ( \"moccasin\" , \"lightsteelblue\" , \"darkolivegreen\" , \"chocolate\" , \"antiquewhite\" , \"springgreen\" , \"steelblue\" , \"tan\" , \"snow\" , \"thistle\" )) dev.off () file.show ( \"n_medias_hist.jpg\" )","title":"Histograma"},{"location":"graficacion/#diagrama-de-dispersion","text":"El diagrama de dispersi\u00f3n muestra la relaci\u00f3n entre dos variables num\u00e9ricas continuas mediante intersecciones entre ellas, por lo que se emplean los argumentos x e y en la funci\u00f3n plot() para situar las variables en los ejes de coordenadas. Normalmente, este tipo de gr\u00e1fico incluye una recta de regresi\u00f3n. Para ello se utiliza la funci\u00f3n lm(y~x) . Ejemplo 1 2 3 4 5 6 7 jpeg ( filename = \"ejemplo_disp.jpg\" , width = 500 , height = 500 ) x1 <- rnorm ( 50 , 4 : 7 ) y1 <- rnorm ( 50 , 11 : 14 ) plot ( x1 , y1 , main = \"Diagrama de dispersi\u00f3n: Ki y Vmax\" , xlab = \"Ki\" , ylab = \"Vmax\" ) regresion <- lm ( y1 ~ x1 ) abline ( regresion , col = \"red\" ) dev.off () Cree un script llamado recta_calibrado.R que devuelva el diagrama de dispersi\u00f3n y la recta de calibrado de \u00e9ste. Respuesta 1 2 3 4 5 6 7 8 9 10 11 print ( \"Indique las concentraciones utilizadas (nM): \" ) x_conc <- scan () print ( \"Indique los pH obtenidos: \" ) y_pH <- scan () jpeg ( filename = \"recta_calibrado.jpg\" , width = 500 , height = 500 ) plot ( x_conc , y_conc main = \"Recta de calibrado\" , xlab = \"Concentraci\u00f3n (mM)\" , ylab = \"pH\" ) r_calibrado <- lm ( y_pH ~ x_conc ) print ( r_calibrado ) abline ( r_calibrado , col = \"blue\" ) dev.off () file.show ( \"recta_calibrado.jpg\" )","title":"Diagrama de dispersi\u00f3n"},{"location":"graficacion/#diagrama-de-caja","text":"El diagrama de caja es una gr\u00e1fica que incluye un rect\u00e1ngulo cuya base inferior es el cuartil 1 (Q1, 25% de los datos) y la base superior el cuartil 3 (Q3, 75% de los datos). El intervalo entre Q3 y Q1 se conoce como rango intercuart\u00edlico (RIC). La divisi\u00f3n de este rect\u00e1ngulo corresponde al cuartil 2 o mediana (Q2, 50% de los datos). Adem\u00e1s, incluye una l\u00ednea que indica el rango de valores no at\u00edpicos, es decir, superiores a Q1\u20131.5\u00b7RIC o inferiores a Q3+1.5\u00b7RIC. Los puntos que sobresalen de estos l\u00edmites son los valores at\u00edpicos. Este gr\u00e1fico tan representativo se obtiene mediante la funci\u00f3n boxplot() . Para ello se necesita precisar la variable continua que se grafica y la variable que se emplea para agrupar, esto es, y y x mediante formula = y ~ x . Ejemplo boxplot() 1 2 3 jpeg ( filename = \"ejemplo_boxplot.jpg\" , width = 500 , height = 500 ) boxplot ( formula = c ( 40 , 20 , 15 , 17 , 10 , 33 , 22 , 36 , 28 , 25 , 42 ) ~ c ( \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"B\" ), main = \"Caja con plot()\" , xlab = \"x\" , ylab = \"y\" , col = c ( \"blue\" , \"red\" )) dev.off () Cree un script llamado notas_grupos.R que genere un gr\u00e1fico de cajas que compare las notas medias de dos grupos de clase distintos Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 13 print ( \"Indique el n\u00famero de alumnos: \" ) n_alumnos <- scan ( n = 1 ) v_notas <- 1 : n_alumnos v_grupos <- 1 : n_alumnos for ( i in 1 : n_alumnos ){ v_grupos [ i ] <- readline ( prompt = \"Indique el grupo: \" ) print ( \"Nota media del alumno correspondiente: \" ) v_notas [ i ] <- scan ( n = 1 ) } jpeg ( filename = \"notas_grupos_boxplot.jpg\" , width = 500 , height = 500 ) boxplot ( formula = v_notas ~ v_grupos , main = \"Notas medias de los grupos de clase \" , xlab = \"Grupos\" , ylab = \"Notas\" , col = c ( \"grey\" , \"seagreen\" )) dev.off () file.show ( \"notas_grupos_boxplot.jpg\" )","title":"Diagrama de caja"},{"location":"graficacion/#grafico-de-sectores","text":"El gr\u00e1fico de sectores, tambi\u00e9n conocido como diagrama de pastel o tarta, es un gr\u00e1fico circular que se emplea para representar porcentajes y proporciones. Su creaci\u00f3n se lleva a cabo mediante la funci\u00f3n pie() que recibe como argumento principal un vector (o tabla) con las frecuencias absolutas de cada clase. Se utiliza el argumento labels para cambiar las etiquetas de cada sector. Para ello toma un vector de cadenas de caracteres. Ejemplo 1 2 3 jpeg ( filename = \"ejemplo_pastel.jpg\" , width = 500 , height = 500 ) pie ( c ( 0.15 , 0.35 , 0.20 , 0.30 ), label = c ( \"A\" , \"B\" , \"C\" , \"D\" ), col = c ( \"red\" , \"yellow\" , \"orange\" , \"brown\" ), main = \"Gr\u00e1fico de sectores\" ) dev.off () Cree un script llamado frecuencia_bases.R que devuelva un gr\u00e1fico de sectores sobre el porcentaje de bases de la cadena de ADN indicada. Respuesta 1 2 3 4 5 6 7 8 9 10 11 12 library ( \"stringr\" ) cad_adn <- readline ( prompt = \"Indique la cadena de ADN: \" ) cad_split <- strsplit ( cad_adn , \"\" ) [[ 1 ]] cad_sort <- sort ( unique ( cad_split )) v_f_cad <- 1 : length ( cad_sort ) for ( i in 1 : length ( cad_sort )){ v_f_cad [ i ] <- str_count ( cad_adn , cad_sort [ i ]) / length ( cad_split ) } jpeg ( filename = \"pastel_f_bases.jpg\" , width = 500 , height = 500 ) pie ( v_f_cad , label = cad_sort , col = c ( \"red\" , \"blue\" , \"green\" , \"yellow\" ), main = \"Frecuencia de bases\" ) dev.off () file.show ( \"pastel_f_bases.jpg\" )","title":"Gr\u00e1fico de sectores"},{"location":"graficacion/#graficacion-avanzada-con-ggplot2","text":"Como se ha comentado al inicio, existen varios paquetes que incrementan la calidad de los gr\u00e1ficos y pueden facilitar el acceso a los datos a graficar. Entre ellos destacan ggplot2 o lattice , empleados para graficar con data frames de un modo avanzado. Este apartado se centra \u00fanicamente en introducir al alumno en el uso de ggplot2 , contenido en la librer\u00eda tidyverse , ya que es el m\u00e1s extendido de los dos. Ambos son muy similares y se solapan en funcionalidades, si bien, ggplot2 es m\u00e1s reciente que lattice . Para entender su funcionamiento se va a utilizar uno de los ficheros utilizados en Importaci\u00f3n y exportaci\u00f3n de datos : csv_tutorial.csv . 1 2 df_csv <- read.csv ( file = \"csv_tutorial.csv\" ) library ( \"ggplot2\" ) La funci\u00f3n b\u00e1sica de ggplot2 para generar un gr\u00e1fico es ggplot() . Atendiendo al contenido del objeto al que se le emplee la funci\u00f3n, se producir\u00e1 un determinado tipo de gr\u00e1fico. No obstante, ggplot() permite aplicar internamente la funci\u00f3n aes() , lo que en la terminolog\u00eda de este paquete se refiere a est\u00e9ticas, es decir, color, distancia horizontal o vertical, forma o tama\u00f1o del punto, etc. Estas est\u00e9ticas se asocian a columnas de datos, de modo que se establezcan seg\u00fan la columna asociada. La forma de representar los datos y las est\u00e9ticas se indican por lo que se conoce como capas en la terminolog\u00eda de ggplot2 . Las capas, como se deduce de su nombre, pueden superponerse. Esto es posible orden\u00e1ndolas como si de una suma se tratase. Existe una gran cantidad de capas, aunque las m\u00e1s usuales son las referidas a gr\u00e1ficos estudiados durante esta secci\u00f3n, como geom_point() , geom_line() , geom_histogram() , geom_bar() o geom_boxplot . Aqu\u00ed puede consultar una lista de las capas disponibles. Como ocurre con R base , cada tipo de gr\u00e1fico, en este caso capa, exige que las variables sean continuas o discretas atendiendo a lo que representa. Ejemplos 1 ejemplo_ggplot <- ggplot ( df_csv , aes ( x = cmo , y = rmsd , col = protb )) + geom_point () + geom_smooth ( method = \"loess\" , se = F ) 1 ejemplo_ggplot2 <- ggplot(df_csv, aes(x = cmo, y = rmsd, col = rmsd)) + geom_point() + geom_smooth(method=\"lm\", col=\"red\") 1 ggplot_boxplot <- ggplot(df_csv, aes(x=protb, y = rmsd, fill=protb)) + geom_boxplot() 1 ggplot_density <- ggplot(df_csv, aes(x=cmo)) + geom_density(aes(fill=protb), position = \"stack\") Las est\u00e9ticas del gr\u00e1fico puede ser modificadas de forma que aparezca el t\u00edtulo y las etiquetas deseadas. Para ello se emplean las funciones ggtitle() y labs() , respectivamente. Ejemplo 1 ejemplo_ggplot3 <- ejemplo_ggplot + ggtitle ( \"Ejemplo con ggplot2: RMSD vs CMO\" ) + labs ( x = \"CMO\" , y = \"RMSD\" , colour = \"RMSD\" ) Otra de las caracter\u00edsticas resaltables de ggplot2 es su capacidad para presentar gr\u00e1ficos conjuntos que hayan sido divididos respecto a diferentes categor\u00edas de una variable mediante facetas como facet_grid() . Adem\u00e1s, ofrece la posibilidad de cambiar de tema, es decir, el aspecto est\u00e9tico del gr\u00e1fico que no tiene que ver con los datos. El paquete contiene diversos temas b\u00e1sicos, pero se pueden instalar librer\u00edas que expandan el n\u00famero con temas m\u00e1s espec\u00edficos, como el paquete ggthemes . Las diversas herramientas que ofrece ggplot2 hacen que la calidad de gr\u00e1fico que permite crear sea incre\u00edble, muestra de ello se puede observar en diversas webs ofrecidas en los enlaces de inter\u00e9s. Ejemplos 1 ggplot_density2 <- ggplot_density + facet_grid ( ~ protb ) 1 ejemplo_ggplot4 <- ejemplo_ggplot2 + theme_wsj() 1 ggplot_density3 <- ggplot_density2 + theme_wsj() Finalmente, el gr\u00e1fico creado se puede exportar a un archivo de extensi\u00f3n PNG , JPG u otros tipos si se indica el formato en el nombre del archivo dentro de la funci\u00f3n ggsave() . Ejemplo 1 ggsave ( \"gg_density_wsj.png\" )","title":"Graficaci\u00f3n avanzada con ggplot2"},{"location":"graficacion/#ejercicio-complementario","text":"Ejercicio resumen El archivo graf_resumen.Rmd contiene un ejercicio de graficaci\u00f3n sobre el conjunto de datos DNase disponible de R, el cual se asemeja a los datos que el alumno puede recoger en una t\u00edpica pr\u00e1ctica del Grado. DNase se carga directamente introduciendo dicho nombre entre comillas en la funci\u00f3n data() . Adem\u00e1s, incluye otro ejercicio sobre los siguientes datos de una clase: clase_resumen.csv . De esta manera se pretende resumir de forma explicativa lo estudiado en este apartado, por lo que requiere la instalaci\u00f3n de la biblioteca tidyverse .","title":"Ejercicio complementario"},{"location":"graficacion/#ejemplo-complementario-de-lattice-boxplot","text":"Ejemplo complementario: boxplot b\u00e1sico con lattice 1 2 3 4 library ( lattice ) jpeg ( filename = \"caja_lattice.jpg\" , width = 500 , height = 500 ) bwplot ( c ( \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"A\" , \"B\" , \"A\" , \"B\" , \"A\" , \"B\" ) ~ c ( 40 , 20 , 15 , 17 , 10 , 33 , 22 , 36 , 28 , 25 , 42 ), main = \"Caja con lattice\" , xlab = \"x\" , ylab = \"y\" , col = c ( \"blue\" , \"red\" )) dev.off () Enlaces de inter\u00e9s R para principiantes. Juan Bosco Mendoza Vega . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba . Nociones generales sobre R. M. Vargas , Universidad de Granada . Colors in R. T. Zheng , Columbia University . R para profesionales de los datos: una introducci\u00f3n. Carlos J. Gil Bellosta . Ejemplos de gr\u00e1ficas Ggplot2 con tema personalizado. El Blog de pmoracho Introducci\u00f3n a la Graficaci\u00f3n con ggplot2. Ronald Delgado","title":"Ejemplo complementario de lattice: boxplot"},{"location":"import_export/","text":"Durante las secciones anteriores del tutorial, se ha estado trabajando con datos que han sido generados por el propio usuario, para facilitar la introducci\u00f3n al lenguaje R. Los siguientes apartados del tutorial podr\u00e1n requerir datos externos para profundizar en temas m\u00e1s espec\u00edficos que tratan sobre la manipulaci\u00f3n de datos. Esto acerca al usuario a un entorno m\u00e1s real, ya que el uso de lenguajes de programaci\u00f3n en la mayor\u00eda de los \u00e1mbitos est\u00e1 dirigido hacia el procesamiento de datos masivos. R base proporciona diferentes funciones de importaci\u00f3n de datos procedentes de una amplia variedad de tipos de archivo. Adem\u00e1s, las diferentes posibilidades de importaci\u00f3n se incrementan con paquetes espec\u00edficos. De forma similar, ser\u00eda posible la exportaci\u00f3n de datos de nuestra sesi\u00f3n de R a archivos disponibles en el ordenador. A lo largo de este apartado se emplear\u00e1n ejemplos que requieren determinados archivos: datos_tutorial , csv_tutorial y excel_tutorial . Puede descargarlos y guardarlos en su directorio de trabajo antes de continuar. Importaci\u00f3n de tablas \u00b6 El m\u00e9todo de importaci\u00f3n de tablas se realiza usando la funci\u00f3n read.table() , que devolver\u00eda un data frame . Existen diferentes modelos de archivos que contienen tablas. Uno de los m\u00e1s extendidos es la extensi\u00f3n .csv , siglas en ingl\u00e9s que le deben el nombre a Comma Separated Values, denominaci\u00f3n que indica la disposici\u00f3n interna de los datos, separados por comas. La importaci\u00f3n de .csv por read.table() requiere de indicaciones mediante argumentos de la funci\u00f3n. Los argumentos m\u00e1s importantes que posee son: file (ruta del archivo a importar), header (interpreta los encabezados como nombres de columnas), sep (caracter separador de columnas), col.names (nombres de las columnas) y stringAsFactors (convierte datos de texto en factores). El otro modo de importar .csv sin necesidad de realizar indicaciones b\u00e1sicas del formato de archivo es mediante la funci\u00f3n read.csv() , que est\u00e1 preparada para las caracter\u00edsticas de este tipo de archivos. Ejemplos 1 2 3 df_tabla_imp <- read.table ( file = \"datos_tutorial.txt\" , header = FALSE , sep = '' , col.names = c ( \"ProtA\" , \"ProtB\" , \"CMO\" , \"RMSD\" )) df_table_csv <- read.table ( file = \"csv_tutorial.csv\" , header = T , sep = ',' ) df_csv <- read.csv ( file = \"csv_tutorial.csv\" ) Sin duda, los formatos m\u00e1s extendidos entre los estudiantes son .xls y .xlsx , propios del programa Microsoft Excel . R base no contiene funciones que importen dichos archivos, pero se puede lograr a trav\u00e9s del paquete readxl , contenido en la biblioteca tidyverse , mencionada en Conceptos b\u00e1sicos , donde se explica el modo de cargar estas herramientas ( library(\"readxl\") ). La funci\u00f3n de readxl que importa archivos Excel es read_excel() . En ella se pueden utilizar argumentos como path (ruta del archivo a importar), sheet (pesta\u00f1a a importar), range (rango de celdas a importar) y col_names (encabezados de las columas). Otra funci\u00f3n que sirve de ayuda es excel_sheets() , que consulta el nombre de las pesta\u00f1as del archivo Excel . Ejemplos 1 2 3 library ( readxl ) excel_sheets ( \"excel_tutorial.xlsx\" ) excel_imp <- read_excel ( path = \"excel_tutorial.xlsx\" , sheet = \"Hoja1\" , range = \"A1:B5\" ) En ocasiones, el archivo a importar puede contener una disposici\u00f3n de los datos desconocida, por lo que visualizar su contenido ayudar\u00eda a conocer las caracter\u00edsticas que deben incluir los argumentos de las funciones anteriores para una importaci\u00f3n correcta y deseada. El modo m\u00e1s simple de observar aquello que conforma el archivo es empleando la funci\u00f3n file.show() . Si bien, se puede contemplar de otros modos como, por ejemplo, l\u00ednea por l\u00ednea, a partir de la funci\u00f3n readLines() , que devuelve un vector de cadenas de las l\u00edneas que constituyen el archivo. Ambas funciones requieren el nombre del archivo entre comillas. Ejemplos 1 2 file.show ( \"csv_tutorial.csv\" ) readLines ( \"csv_tutorial.csv\" ) Exportaci\u00f3n de tablas \u00b6 Para exportar tablas, ya sean matrices o data frames , se puede utilizar la funci\u00f3n write.table() , donde se requiere los argumentos x y file , para el nombre del objeto y del archivo a crear, y tambi\u00e9n se emplea sep para indicar la separaci\u00f3n de los datos entre columnas. Si bien, se puede exportar en formato .csv mediante la funci\u00f3n write.csv() . En cuanto a la exportaci\u00f3n en formato Excel , es necesario instalar el paquete writexl , el cual presenta la funci\u00f3n write_xlsx() para llevar a cabo dicha acci\u00f3n. Ejemplos 1 2 3 4 5 write.table ( x = df_table_csv , file = \"df_table_csv\" , sep = \",\" ) write.csv ( x = df_table_csv , file = \"df_table.csv\" ) install.packages ( \"writexl\" ) library ( writexl ) write_xlsx ( excel_imp , \"excel_exp.xlsx\" ) Importaci\u00f3n y exportaci\u00f3n de objetos de una sesi\u00f3n de R \u00b6 Por otro lado, se puede exportar todo tipo de objetos de nuestra sesi\u00f3n mediante las funciones saveRDS() y save() , que generan archivos de extensi\u00f3n .rds y .Rdata , y pueden ser abiertos \u00fanicamente por R mediante readRDS() y load() , respectivamente. La principal diferencia entre ellas radica en que save() permite guardar m\u00e1s de un objeto. Si no son asignados a una variable solamente se podr\u00e1 obervar su contenido en el terminal. Ejemplos 1 2 3 4 saveRDS ( object = list ( \"a\" = c ( 1 , 2 ), \"b\" = c ( 3 , 4 ), \"c\" = c ( 5 , 6 )), file = \"lista_exp.rds\" ) lista_rds <- readRDS ( lista_exp.rds ) save ( df_table_csv , df_csv , file = \"ejemplo_save.Rdata\" ) load ( \"ejemplo_save.Rdata\" ) Enlaces de inter\u00e9s R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Importaci\u00f3n y exportaci\u00f3n de datos"},{"location":"import_export/#importacion-de-tablas","text":"El m\u00e9todo de importaci\u00f3n de tablas se realiza usando la funci\u00f3n read.table() , que devolver\u00eda un data frame . Existen diferentes modelos de archivos que contienen tablas. Uno de los m\u00e1s extendidos es la extensi\u00f3n .csv , siglas en ingl\u00e9s que le deben el nombre a Comma Separated Values, denominaci\u00f3n que indica la disposici\u00f3n interna de los datos, separados por comas. La importaci\u00f3n de .csv por read.table() requiere de indicaciones mediante argumentos de la funci\u00f3n. Los argumentos m\u00e1s importantes que posee son: file (ruta del archivo a importar), header (interpreta los encabezados como nombres de columnas), sep (caracter separador de columnas), col.names (nombres de las columnas) y stringAsFactors (convierte datos de texto en factores). El otro modo de importar .csv sin necesidad de realizar indicaciones b\u00e1sicas del formato de archivo es mediante la funci\u00f3n read.csv() , que est\u00e1 preparada para las caracter\u00edsticas de este tipo de archivos. Ejemplos 1 2 3 df_tabla_imp <- read.table ( file = \"datos_tutorial.txt\" , header = FALSE , sep = '' , col.names = c ( \"ProtA\" , \"ProtB\" , \"CMO\" , \"RMSD\" )) df_table_csv <- read.table ( file = \"csv_tutorial.csv\" , header = T , sep = ',' ) df_csv <- read.csv ( file = \"csv_tutorial.csv\" ) Sin duda, los formatos m\u00e1s extendidos entre los estudiantes son .xls y .xlsx , propios del programa Microsoft Excel . R base no contiene funciones que importen dichos archivos, pero se puede lograr a trav\u00e9s del paquete readxl , contenido en la biblioteca tidyverse , mencionada en Conceptos b\u00e1sicos , donde se explica el modo de cargar estas herramientas ( library(\"readxl\") ). La funci\u00f3n de readxl que importa archivos Excel es read_excel() . En ella se pueden utilizar argumentos como path (ruta del archivo a importar), sheet (pesta\u00f1a a importar), range (rango de celdas a importar) y col_names (encabezados de las columas). Otra funci\u00f3n que sirve de ayuda es excel_sheets() , que consulta el nombre de las pesta\u00f1as del archivo Excel . Ejemplos 1 2 3 library ( readxl ) excel_sheets ( \"excel_tutorial.xlsx\" ) excel_imp <- read_excel ( path = \"excel_tutorial.xlsx\" , sheet = \"Hoja1\" , range = \"A1:B5\" ) En ocasiones, el archivo a importar puede contener una disposici\u00f3n de los datos desconocida, por lo que visualizar su contenido ayudar\u00eda a conocer las caracter\u00edsticas que deben incluir los argumentos de las funciones anteriores para una importaci\u00f3n correcta y deseada. El modo m\u00e1s simple de observar aquello que conforma el archivo es empleando la funci\u00f3n file.show() . Si bien, se puede contemplar de otros modos como, por ejemplo, l\u00ednea por l\u00ednea, a partir de la funci\u00f3n readLines() , que devuelve un vector de cadenas de las l\u00edneas que constituyen el archivo. Ambas funciones requieren el nombre del archivo entre comillas. Ejemplos 1 2 file.show ( \"csv_tutorial.csv\" ) readLines ( \"csv_tutorial.csv\" )","title":"Importaci\u00f3n de tablas"},{"location":"import_export/#exportacion-de-tablas","text":"Para exportar tablas, ya sean matrices o data frames , se puede utilizar la funci\u00f3n write.table() , donde se requiere los argumentos x y file , para el nombre del objeto y del archivo a crear, y tambi\u00e9n se emplea sep para indicar la separaci\u00f3n de los datos entre columnas. Si bien, se puede exportar en formato .csv mediante la funci\u00f3n write.csv() . En cuanto a la exportaci\u00f3n en formato Excel , es necesario instalar el paquete writexl , el cual presenta la funci\u00f3n write_xlsx() para llevar a cabo dicha acci\u00f3n. Ejemplos 1 2 3 4 5 write.table ( x = df_table_csv , file = \"df_table_csv\" , sep = \",\" ) write.csv ( x = df_table_csv , file = \"df_table.csv\" ) install.packages ( \"writexl\" ) library ( writexl ) write_xlsx ( excel_imp , \"excel_exp.xlsx\" )","title":"Exportaci\u00f3n de tablas"},{"location":"import_export/#importacion-y-exportacion-de-objetos-de-una-sesion-de-r","text":"Por otro lado, se puede exportar todo tipo de objetos de nuestra sesi\u00f3n mediante las funciones saveRDS() y save() , que generan archivos de extensi\u00f3n .rds y .Rdata , y pueden ser abiertos \u00fanicamente por R mediante readRDS() y load() , respectivamente. La principal diferencia entre ellas radica en que save() permite guardar m\u00e1s de un objeto. Si no son asignados a una variable solamente se podr\u00e1 obervar su contenido en el terminal. Ejemplos 1 2 3 4 saveRDS ( object = list ( \"a\" = c ( 1 , 2 ), \"b\" = c ( 3 , 4 ), \"c\" = c ( 5 , 6 )), file = \"lista_exp.rds\" ) lista_rds <- readRDS ( lista_exp.rds ) save ( df_table_csv , df_csv , file = \"ejemplo_save.Rdata\" ) load ( \"ejemplo_save.Rdata\" ) Enlaces de inter\u00e9s R para principiantes. Juan Bosco Mendoza Vega . Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica . Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Importaci\u00f3n y exportaci\u00f3n de objetos de una sesi\u00f3n de R"},{"location":"variable_objetos_operadores/","text":"Variables \u00b6 En programaci\u00f3n, se alude a la variable como el nombre simb\u00f3lico o identificador que se asocia a un dato que se almacena en la memoria principal del ordenador. A diferencia de una constante, cuyo valor no puede cambiar, el dato que almacena la variable puede, como el t\u00e9rmino indica, variar durante la ejecuci\u00f3n del programa. El nombre puede incluir letras, n\u00fameros, puntos y guiones bajos, aunque debe empezar siempre con una letra o un punto. En este \u00faltimo caso, tras el punto no se permite seguir con un n\u00famero. No puede contener \u00f1, tildes o s\u00edmbolos que no sean del alfabeto. Hay que tener en cuenta que el nombre no debe de ser ambiguo, sino lo m\u00e1s claro y descriptivo posible, de forma que no conduzca a confusi\u00f3n y sea m\u00e1s f\u00e1cil de comprender tanto por nosotros mismos como por otras personas. Generar una variable El procedimiento general para crear una variable ser\u00eda el siguiente: escribes el nombre de tu variable, incluyes el operador de asignaci\u00f3n <- , y contin\u00faas con el dato que quieras incluir, el cual determina el tipo de operaciones a las que puede someterse la variable. De este modo, quedar\u00eda tal que as\u00ed: nombre_variable <- dato . Si bien, es cierto que ser\u00eda posible asignar variables de otras formas como las siguientes: dato -> nombre_variable , assign(\"nombres_variable\", dato) , nombre_variable = dato . Objetos at\u00f3micos \u00b6 Todo lo que conforma R se considera un objeto. Partiendo de los m\u00e1s simples, los m\u00ednimos elementos de las variables se conocen como at\u00f3micos y pueden componer estructuras de datos (vectores, factores, matrices y listas), que ser\u00edan objetos recursivos y tambi\u00e9n pueden componer una variable. A continuaci\u00f3n, se muestran los distintos tipos de objetos at\u00f3micos en los que se basa R, los cuales pueden comprobarse aplicando las funciones mode() , class(nombre_variable) o is. . L\u00f3gico: tambi\u00e9n conocido como booleano, representa valores de l\u00f3gica binaria, es decir, valores 0 y 1 como falso y verdadero, respectivamente, que se pueden indicar como FALSE , F , TRUE o T . Ejemplos 1 2 logico <- TRUE booleano <- F Num\u00e9rico: representa valores numerales tanto enteros como reales. Existe otros tipos de datos como el denominado integer , el cual es m\u00e1s estricto ya que se refiere \u00fanicamente a los valores enteros, y el tipo de dato complex , que se relaciona con los n\u00fameros complejos cuya forma es b+2i . Generalmente se emplean datos numeric y pueden proceder de operaciones. Ejemplos 1 2 3 4 num_entero = 5-15 assign ( \"num_real\" , 5.43 ) num_integer <- 2L num_complejo <- 4+3i Car\u00e1cter: d\u00edgito individual que puede ser representado por un s\u00edmbolo del lenguaje natural, lo que incluye letras, n\u00fameros, espacios en blanco o signos, y que tienen que indicarse entre comillas. Estos pueden presentarse como una secuencia ordenada de forma que compongan una cadena de caracteres . Para crear una cadena se utilizan comillas simples o dobles sin diferencias en su comportamiento. Si bien, las comillas dobles es la opci\u00f3n m\u00e1s extendida aunque, si la cadena contiene comillas como elementos, se emplean las comillas simples. Ejemplos 1 2 caracter <- '\u00a1' cadena <- \"1. #ADN1#ATGCGACCAGTT\" Nulo: se da con valores indefinidos que suelen importarse o proceden de una operaci\u00f3n. Tambi\u00e9n podr\u00eda entenderse como una variable vac\u00eda. Se definen con la palabra reservada NULL . Ejemplo 1 nulo <- NULL \u00bfQu\u00e9 valor contienen los siguientes ejemplos de variable? 1 2 3 4 5 6 7 variable1 <- 1 / 0 variable2 <- 0 / 0 variable3 <- NA variable4 <- as.integer ( variable1 ) variable5 <- \"3 + 2\" variable6 <- 3 + 2 variable7 <- T Respuesta La variable variable1 contiene un valor infinito, el cual se muestra como Inf . Este valor es resultado de c\u00e1lculos donde se divide entre cero o se obtiene un n\u00famero muy grande. variable2 no representa un valor num\u00e9rico, lo que se indica como NaN ( Not a Number ). Esto resulta de operaciones con indeterminaciones. Tanto Inf como NaN son variables de tipo num\u00e9rico. En el caso de variable3 , la variable contiene un valor no disponible, mostrado como NA . Este tipo de objeto se considera como l\u00f3gico por defecto, a menos que se coercionen a otro tipo mediante funciones como la que se emplea en la variable4 o semejantes, como as.character() o as.numeric() . Las variables variable5 , variable6 y variable7 contienen elementos de tipo car\u00e1cter, num\u00e9rico y l\u00f3gico, respectivamente. Operadores \u00b6 L\u00f3gicos \u00b6 Los operadores l\u00f3gicos | y & describen relaciones l\u00f3gicas que se pueden entender como \"uno u otro es TRUE \" y \"ambos son TRUE \", respectivamente. Por tanto, la relaci\u00f3n | devuelve TRUE si alguno de los datos es TRUE , y la relaci\u00f3n & solo da la salida TRUE si ambos datos son TRUE . Ejemplos 1 2 3 relacion1 <- F | F relacion2 <- T & F relacion3 <- ! 5 | 1 Aritm\u00e9ticos \u00b6 Los operadores aritm\u00e9ticos, como su nombre indica, se emplean para operaciones aritm\u00e9ticas, es decir, c\u00e1lculos matem\u00e1ticos, por lo que son permitidos para datos de tipo entero, num\u00e9rico y complejo. Operador Comparaci\u00f3n + Suma - Resta * Multiplicaci\u00f3n / Divisi\u00f3n ^ Potencia %% Divisi\u00f3n entera R funciona como una calculadora, donde se emplean los operadores aritm\u00e9ticos mencionados y una gran cantidad de funciones matem\u00e1ticas como la ra\u00edz cuadrada, sqrt() , el logaritmo, log() , el exponente, exp() o el seno, sin() , entre otras. Relacionales \u00b6 Los operadores relacionales realizan comparaciones y siempre devuelven como resultado TRUE o FALSE . A diferencia de los operadores aritm\u00e9ticos, se puede emplear en cadenas de caracteres, pero toma en cuenta el primer car\u00e1cter de cada dato y compara por orden alfab\u00e9tico. Operador Comparaci\u00f3n < Menor que <= Menor o igual que > Mayor que >= Mayor o igual que == Exactamente igual que != No es igual que Jerarqu\u00eda de operadores \u00b6 Tanto los operadores aritm\u00e9ticos como los relacionales y los l\u00f3gicos est\u00e1n jerarquizados, de modo que se efect\u00faen preferentemente ciertas operaciones, dejando en \u00faltimo lugar el operador de asignaci\u00f3n de varible. Orden Operador 1 ^ 2 * / 3 + - 4 Relacionales 5 & 6 | 7 <- Ejemplos 1 2 3 relacion4 <- num_entero != num_complejo relacion5 <- cadena > caracter relacion6 <- num_entero * -2 <= num_real & cadena == caracter Ejercicios complementarios \u00b6 Cree un script llamado Kelvin_a_Celsius.R que transforme grados Kelvin en grados Celsius (cent\u00edgrados). Respuesta 1 2 3 4 print ( \"Indique grados Kelvin:\" ) kelvin <- scan ( n = 1 ) celsius <- kelvin - 273.15 cat ( kelvin , \"K son\" , celsius , \"\u00baC.\\n\" ) ** MJ : NO OLVIDES USAR EL \\ n CON CAT ** Cree un script llamado pesetas_a_euros.R que calcule la equivalencia de pesetas en euros. Respuesta 1 2 3 4 print ( \"Indique cantidad pesetas:\" ) pesetas <- scan ( n = 1 ) euros <- pesetas * 0.006 cat ( pesetas , \"pesetas son\" , euros , \"euros.\\n\" ) Cree un script llamado segundos.R que desglose una cantidad de segundos en d\u00edas, horas y minutos equivalentes. Respuesta 1 2 3 4 5 6 print ( \"Indique segundos:\" ) segundos <- scan ( n = 1 ) minutos <- segundos / 60 horas <- minutos / 60 dias <- horas / 24 cat ( segundos , \"segundos son\" , minutos , \"minutos,\" , horas , \"horas y\" , dias , \"d\u00edas.\\n\" ) Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica , Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Variables, objetos at\u00f3micos y operadores"},{"location":"variable_objetos_operadores/#variables","text":"En programaci\u00f3n, se alude a la variable como el nombre simb\u00f3lico o identificador que se asocia a un dato que se almacena en la memoria principal del ordenador. A diferencia de una constante, cuyo valor no puede cambiar, el dato que almacena la variable puede, como el t\u00e9rmino indica, variar durante la ejecuci\u00f3n del programa. El nombre puede incluir letras, n\u00fameros, puntos y guiones bajos, aunque debe empezar siempre con una letra o un punto. En este \u00faltimo caso, tras el punto no se permite seguir con un n\u00famero. No puede contener \u00f1, tildes o s\u00edmbolos que no sean del alfabeto. Hay que tener en cuenta que el nombre no debe de ser ambiguo, sino lo m\u00e1s claro y descriptivo posible, de forma que no conduzca a confusi\u00f3n y sea m\u00e1s f\u00e1cil de comprender tanto por nosotros mismos como por otras personas. Generar una variable El procedimiento general para crear una variable ser\u00eda el siguiente: escribes el nombre de tu variable, incluyes el operador de asignaci\u00f3n <- , y contin\u00faas con el dato que quieras incluir, el cual determina el tipo de operaciones a las que puede someterse la variable. De este modo, quedar\u00eda tal que as\u00ed: nombre_variable <- dato . Si bien, es cierto que ser\u00eda posible asignar variables de otras formas como las siguientes: dato -> nombre_variable , assign(\"nombres_variable\", dato) , nombre_variable = dato .","title":"Variables"},{"location":"variable_objetos_operadores/#objetos-atomicos","text":"Todo lo que conforma R se considera un objeto. Partiendo de los m\u00e1s simples, los m\u00ednimos elementos de las variables se conocen como at\u00f3micos y pueden componer estructuras de datos (vectores, factores, matrices y listas), que ser\u00edan objetos recursivos y tambi\u00e9n pueden componer una variable. A continuaci\u00f3n, se muestran los distintos tipos de objetos at\u00f3micos en los que se basa R, los cuales pueden comprobarse aplicando las funciones mode() , class(nombre_variable) o is. . L\u00f3gico: tambi\u00e9n conocido como booleano, representa valores de l\u00f3gica binaria, es decir, valores 0 y 1 como falso y verdadero, respectivamente, que se pueden indicar como FALSE , F , TRUE o T . Ejemplos 1 2 logico <- TRUE booleano <- F Num\u00e9rico: representa valores numerales tanto enteros como reales. Existe otros tipos de datos como el denominado integer , el cual es m\u00e1s estricto ya que se refiere \u00fanicamente a los valores enteros, y el tipo de dato complex , que se relaciona con los n\u00fameros complejos cuya forma es b+2i . Generalmente se emplean datos numeric y pueden proceder de operaciones. Ejemplos 1 2 3 4 num_entero = 5-15 assign ( \"num_real\" , 5.43 ) num_integer <- 2L num_complejo <- 4+3i Car\u00e1cter: d\u00edgito individual que puede ser representado por un s\u00edmbolo del lenguaje natural, lo que incluye letras, n\u00fameros, espacios en blanco o signos, y que tienen que indicarse entre comillas. Estos pueden presentarse como una secuencia ordenada de forma que compongan una cadena de caracteres . Para crear una cadena se utilizan comillas simples o dobles sin diferencias en su comportamiento. Si bien, las comillas dobles es la opci\u00f3n m\u00e1s extendida aunque, si la cadena contiene comillas como elementos, se emplean las comillas simples. Ejemplos 1 2 caracter <- '\u00a1' cadena <- \"1. #ADN1#ATGCGACCAGTT\" Nulo: se da con valores indefinidos que suelen importarse o proceden de una operaci\u00f3n. Tambi\u00e9n podr\u00eda entenderse como una variable vac\u00eda. Se definen con la palabra reservada NULL . Ejemplo 1 nulo <- NULL \u00bfQu\u00e9 valor contienen los siguientes ejemplos de variable? 1 2 3 4 5 6 7 variable1 <- 1 / 0 variable2 <- 0 / 0 variable3 <- NA variable4 <- as.integer ( variable1 ) variable5 <- \"3 + 2\" variable6 <- 3 + 2 variable7 <- T Respuesta La variable variable1 contiene un valor infinito, el cual se muestra como Inf . Este valor es resultado de c\u00e1lculos donde se divide entre cero o se obtiene un n\u00famero muy grande. variable2 no representa un valor num\u00e9rico, lo que se indica como NaN ( Not a Number ). Esto resulta de operaciones con indeterminaciones. Tanto Inf como NaN son variables de tipo num\u00e9rico. En el caso de variable3 , la variable contiene un valor no disponible, mostrado como NA . Este tipo de objeto se considera como l\u00f3gico por defecto, a menos que se coercionen a otro tipo mediante funciones como la que se emplea en la variable4 o semejantes, como as.character() o as.numeric() . Las variables variable5 , variable6 y variable7 contienen elementos de tipo car\u00e1cter, num\u00e9rico y l\u00f3gico, respectivamente.","title":"Objetos at\u00f3micos"},{"location":"variable_objetos_operadores/#operadores","text":"","title":"Operadores"},{"location":"variable_objetos_operadores/#logicos","text":"Los operadores l\u00f3gicos | y & describen relaciones l\u00f3gicas que se pueden entender como \"uno u otro es TRUE \" y \"ambos son TRUE \", respectivamente. Por tanto, la relaci\u00f3n | devuelve TRUE si alguno de los datos es TRUE , y la relaci\u00f3n & solo da la salida TRUE si ambos datos son TRUE . Ejemplos 1 2 3 relacion1 <- F | F relacion2 <- T & F relacion3 <- ! 5 | 1","title":"L\u00f3gicos"},{"location":"variable_objetos_operadores/#aritmeticos","text":"Los operadores aritm\u00e9ticos, como su nombre indica, se emplean para operaciones aritm\u00e9ticas, es decir, c\u00e1lculos matem\u00e1ticos, por lo que son permitidos para datos de tipo entero, num\u00e9rico y complejo. Operador Comparaci\u00f3n + Suma - Resta * Multiplicaci\u00f3n / Divisi\u00f3n ^ Potencia %% Divisi\u00f3n entera R funciona como una calculadora, donde se emplean los operadores aritm\u00e9ticos mencionados y una gran cantidad de funciones matem\u00e1ticas como la ra\u00edz cuadrada, sqrt() , el logaritmo, log() , el exponente, exp() o el seno, sin() , entre otras.","title":"Aritm\u00e9ticos"},{"location":"variable_objetos_operadores/#relacionales","text":"Los operadores relacionales realizan comparaciones y siempre devuelven como resultado TRUE o FALSE . A diferencia de los operadores aritm\u00e9ticos, se puede emplear en cadenas de caracteres, pero toma en cuenta el primer car\u00e1cter de cada dato y compara por orden alfab\u00e9tico. Operador Comparaci\u00f3n < Menor que <= Menor o igual que > Mayor que >= Mayor o igual que == Exactamente igual que != No es igual que","title":"Relacionales"},{"location":"variable_objetos_operadores/#jerarquia-de-operadores","text":"Tanto los operadores aritm\u00e9ticos como los relacionales y los l\u00f3gicos est\u00e1n jerarquizados, de modo que se efect\u00faen preferentemente ciertas operaciones, dejando en \u00faltimo lugar el operador de asignaci\u00f3n de varible. Orden Operador 1 ^ 2 * / 3 + - 4 Relacionales 5 & 6 | 7 <- Ejemplos 1 2 3 relacion4 <- num_entero != num_complejo relacion5 <- cadena > caracter relacion6 <- num_entero * -2 <= num_real & cadena == caracter","title":"Jerarqu\u00eda de operadores"},{"location":"variable_objetos_operadores/#ejercicios-complementarios","text":"Cree un script llamado Kelvin_a_Celsius.R que transforme grados Kelvin en grados Celsius (cent\u00edgrados). Respuesta 1 2 3 4 print ( \"Indique grados Kelvin:\" ) kelvin <- scan ( n = 1 ) celsius <- kelvin - 273.15 cat ( kelvin , \"K son\" , celsius , \"\u00baC.\\n\" ) ** MJ : NO OLVIDES USAR EL \\ n CON CAT ** Cree un script llamado pesetas_a_euros.R que calcule la equivalencia de pesetas en euros. Respuesta 1 2 3 4 print ( \"Indique cantidad pesetas:\" ) pesetas <- scan ( n = 1 ) euros <- pesetas * 0.006 cat ( pesetas , \"pesetas son\" , euros , \"euros.\\n\" ) Cree un script llamado segundos.R que desglose una cantidad de segundos en d\u00edas, horas y minutos equivalentes. Respuesta 1 2 3 4 5 6 print ( \"Indique segundos:\" ) segundos <- scan ( n = 1 ) minutos <- segundos / 60 horas <- minutos / 60 dias <- horas / 24 cat ( segundos , \"segundos son\" , minutos , \"minutos,\" , horas , \"horas y\" , dias , \"d\u00edas.\\n\" ) Enlaces de inter\u00e9s R para An\u00e1lisis Cient\u00edficos Reproducibles. Software Carpentry. R para principiantes. Juan Bosco Mendoza Vega . El arte de programar en R: Un lenguaje para la estad\u00edstica. Julio Sergio Santana & Efra\u00edn Mateos Farf\u00e1n. Material del curso Inform\u00e1tica aplicada a la Bioqu\u00edmica , Manuel Jes\u00fas Mar\u00edn Jim\u00e9nez , Universidad de C\u00f3rdoba .","title":"Ejercicios complementarios"}]}